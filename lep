#!/usr/bin/env bash
# This script was generated by bashly 1.0.7 (https://bashly.dannyb.co)
# Modifying it manually is not recommended

# :wrapper.bash3_bouncer
if [[ "${BASH_VERSINFO:-0}" -lt 4 ]]; then
  printf "bash version 4 or higher is required\n" >&2
  exit 1
fi

# :command.master_script

# :command.version_command
version_command() {
  echo "$version"
}

# :command.usage
lep_usage() {
  if [[ -n $long_usage ]]; then
    printf "lep - Manage the laufendentdecken podcast via terminal\n"
    echo

  else
    printf "lep - Manage the laufendentdecken podcast via terminal\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  lep COMMAND\n"
  printf "  lep [COMMAND] --help | -h\n"
  printf "  lep --version | -v\n"
  echo
  # :command.usage_commands
  printf "%s\n" "Commands:"
  printf "  %s   Generate bash completions\n" "completions   "
  printf "  %s   Initialize episode\n" "init          "
  printf "  %s   Edit current episode description\n" "edit          "
  printf "  %s   Create a new iteration\n" "new           "
  printf "  %s   Check if ready to start automation\n" "check         "
  printf "  %s   Download file from ftp server\n" "download      "
  printf "  %s   Generate episode metadata\n" "metadata      "
  printf "  %s   Configure youtube video\n" "youtube       "
  printf "  %s   Upload file to self hosted ftp server\n" "ftp           "
  printf "  %s   Upload latest episode to youtube and start automatic post processing workflow\n" "upload-youtube"
  printf "  %s   Upload latest episode and start automatic post processing workflow\n" "automation    "
  printf "  %s   Start new auphonic production\n" "auphonic      "
  printf "  %s   Create wordpress blogpost on http://laufendentdecken-podcast.at\n" "blogpost      "
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo
    printf "  %s\n" "--version, -v"
    printf "    Show version number\n"
    echo

  fi
}

# :command.usage
lep_completions_usage() {
  if [[ -n $long_usage ]]; then
    printf "lep completions\n"
    echo

    printf "  Generate bash completions\n  Usage: eval \"\$(lep completions)\"\n"
    echo

  else
    printf "lep completions - Generate bash completions\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  lep completions\n"
  printf "  lep completions --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
lep_init_usage() {
  if [[ -n $long_usage ]]; then
    printf "lep init - Initialize episode\n"
    echo

  else
    printf "lep init - Initialize episode\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  lep init\n"
  printf "  lep init --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
lep_edit_usage() {
  if [[ -n $long_usage ]]; then
    printf "lep edit - Edit current episode description\n"
    echo

  else
    printf "lep edit - Edit current episode description\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  lep edit\n"
  printf "  lep edit --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
lep_new_usage() {
  if [[ -n $long_usage ]]; then
    printf "lep new - Create a new iteration\n"
    echo

  else
    printf "lep new - Create a new iteration\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  lep new\n"
  printf "  lep new --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
lep_check_usage() {
  if [[ -n $long_usage ]]; then
    printf "lep check - Check if ready to start automation\n"
    echo

  else
    printf "lep check - Check if ready to start automation\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  lep check [OPTIONS]\n"
  printf "  lep check --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--skip-youtube"
    printf "    Skip scheduling youtube video\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
lep_download_usage() {
  if [[ -n $long_usage ]]; then
    printf "lep download - Download file from ftp server\n"
    echo

  else
    printf "lep download - Download file from ftp server\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  lep download [OPTIONS]\n"
  printf "  lep download --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--file, -f FILE (required)"
    printf "    File to download\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
lep_metadata_usage() {
  if [[ -n $long_usage ]]; then
    printf "lep metadata - Generate episode metadata\n"
    echo

  else
    printf "lep metadata - Generate episode metadata\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  lep metadata [OPTIONS]\n"
  printf "  lep metadata --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--title, -t TITLE (required)"
    printf "    Episode Title\n"
    echo

    # :flag.usage
    printf "  %s\n" "--debug"
    printf "    Don't change any state in 1password\n"
    echo

    # :flag.usage
    printf "  %s\n" "--no-default-releasedate"
    printf "    Change default release date\n"
    echo

    # :flag.usage
    printf "  %s\n" "--no-default-postnumber"
    printf "    Change default post number\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
lep_youtube_usage() {
  if [[ -n $long_usage ]]; then
    printf "lep youtube - Configure youtube video\n"
    echo

  else
    printf "lep youtube - Configure youtube video\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  lep youtube [OPTIONS]\n"
  printf "  lep youtube --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--title, -t TITLE (required)"
    printf "    Episode Title\n"
    echo

    # :flag.usage
    printf "  %s\n" "--publish_date, -p PUBLISH_DATE (required)"
    printf "    Publish Date\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
lep_ftp_usage() {
  if [[ -n $long_usage ]]; then
    printf "lep ftp - Upload file to self hosted ftp server\n"
    echo

  else
    printf "lep ftp - Upload file to self hosted ftp server\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  lep ftp [OPTIONS]\n"
  printf "  lep ftp --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--file, -f FILE (required)"
    printf "    File to upload\n"
    echo

    # :flag.usage
    printf "  %s\n" "--name, -n NAME (required)"
    printf "    Name of file on server\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
lep_upload_youtube_usage() {
  if [[ -n $long_usage ]]; then
    printf "lep upload-youtube - Upload latest episode to youtube and start automatic post processing workflow\n"
    echo

  else
    printf "lep upload-youtube - Upload latest episode to youtube and start automatic post processing workflow\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  lep upload-youtube\n"
  printf "  lep upload-youtube --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
lep_automation_usage() {
  if [[ -n $long_usage ]]; then
    printf "lep automation - Upload latest episode and start automatic post processing workflow\n"
    echo

  else
    printf "lep automation - Upload latest episode and start automatic post processing workflow\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  lep automation [OPTIONS]\n"
  printf "  lep automation --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--m4a, -m M4A"
    printf "    Episode as m4a\n"
    echo

    # :flag.usage
    printf "  %s\n" "--time TIME"
    printf "    Start time of the episode\n"
    printf "    Default: 09:00:00\n"
    echo

    # :flag.usage
    printf "  %s\n" "--force"
    printf "    No sanity check before automation starts\n"
    echo

    # :flag.usage
    printf "  %s\n" "--ag1"
    printf "    This episodes is supportd by AG1\n"
    echo

    # :flag.usage
    printf "  %s\n" "--polestar"
    printf "    This episodes is supportd by Polestar\n"
    echo

    # :flag.usage
    printf "  %s\n" "--debug"
    printf "    Dont change\n"
    echo

    # :flag.usage
    printf "  %s\n" "--no-default-releasedate"
    printf "    Change default release date\n"
    echo

    # :flag.usage
    printf "  %s\n" "--skip-ftp"
    printf "    Skip upload to FTP server\n"
    echo

    # :flag.usage
    printf "  %s\n" "--skip-aws"
    printf "    Skip upload to aws\n"
    echo

    # :flag.usage
    printf "  %s\n" "--skip-auphonic"
    printf "    Skip upload to Auphonic\n"
    echo

    # :flag.usage
    printf "  %s\n" "--skip-download"
    printf "    Skip download from patreon\n"
    echo

    # :flag.usage
    printf "  %s\n" "--skip-blogpost"
    printf "    Skip create blogpost\n"
    echo

    # :flag.usage
    printf "  %s\n" "--skip-youtube"
    printf "    Skip scheduling youtube video\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  lep upload --m4a episode.m4a\n"
    echo

  fi
}

# :command.usage
lep_auphonic_usage() {
  if [[ -n $long_usage ]]; then
    printf "lep auphonic - Start new auphonic production\n"
    echo

  else
    printf "lep auphonic - Start new auphonic production\n"
    echo

  fi

  printf "Alias: a\n"
  echo

  printf "%s\n" "Usage:"
  printf "  lep auphonic [OPTIONS]\n"
  printf "  lep auphonic --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--production_name, -n PRODUCTION_NAME (required)"
    printf "    Auphonic production name\n"
    echo

    # :flag.usage
    printf "  %s\n" "--preset, -p PRESET (required)"
    printf "    Auphonic preset\n"
    echo

    # :flag.usage
    printf "  %s\n" "--cover_url, -c COVER_URL (required)"
    printf "    URL of the cover image\n"
    echo

    # :flag.usage
    printf "  %s\n" "--file, -f FILE (required)"
    printf "    File name of the production\n"
    echo

    # :flag.usage
    printf "  %s\n" "--slug, -s SLUG (required)"
    printf "    Slug of the auphonic production\n"
    echo

    # :flag.usage
    printf "  %s\n" "--description, -d DESCRIPTION"
    printf "    Description of the episode\n"
    echo

    # :flag.usage
    printf "  %s\n" "--no-start"
    printf "    Dont automatically start the auphonic production\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  lep auphonic --production_name episode1 --preset \"123823\" --cover_url\n  \"http://url\" --file episode1.m4a --slug episode1\n"
    echo

  fi
}

# :command.usage
lep_blogpost_usage() {
  if [[ -n $long_usage ]]; then
    printf "lep blogpost - Create wordpress blogpost on http://laufendentdecken-podcast.at\n"
    echo

  else
    printf "lep blogpost - Create wordpress blogpost on http://laufendentdecken-podcast.at\n"
    echo

  fi

  printf "Alias: cb\n"
  echo

  printf "%s\n" "Usage:"
  printf "  lep blogpost [OPTIONS]\n"
  printf "  lep blogpost --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--ag1"
    printf "    This episodes is supportd by AG1\n"
    echo

    # :flag.usage
    printf "  %s\n" "--polestar"
    printf "    This episodes is supportd by Polestar\n"
    echo

    # :flag.usage
    printf "  %s\n" "--number, -n NUMBER (required)"
    printf "    Episode Number\n"
    echo

    # :flag.usage
    printf "  %s\n" "--title, -t TITLE (required)"
    printf "    Episode Title\n"
    echo

    # :flag.usage
    printf "  %s\n" "--publish_date, -p PUBLISH_DATE (required)"
    printf "    Publish Date\n"
    echo

    # :flag.usage
    printf "  %s\n" "--slug, -s SLUG (required)"
    printf "    Slug of the auphonic production\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  lep create-blogpost --number 1 --title \"Episode Title\" --publish_date\n  \"2049-12-31\" --slug \"slug\"\n"
    echo

  fi
}

# :command.normalize_input
normalize_input() {
  local arg flags

  while [[ $# -gt 0 ]]; do
    arg="$1"
    if [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then
      flags="${BASH_REMATCH[1]}"
      for ((i = 0; i < ${#flags}; i++)); do
        input+=("-${flags:i:1}")
      done
    else
      input+=("$arg")
    fi

    shift
  done
}
# :command.inspect_args
inspect_args() {
  if ((${#args[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!args[@]}" | sort)
    echo args:
    for k in "${sorted_keys[@]}"; do echo "- \${args[$k]} = ${args[$k]}"; done
  else
    echo args: none
  fi

  if ((${#other_args[@]})); then
    echo
    echo other_args:
    echo "- \${other_args[*]} = ${other_args[*]}"
    for i in "${!other_args[@]}"; do
      echo "- \${other_args[$i]} = ${other_args[$i]}"
    done
  fi

  if ((${#deps[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!deps[@]}" | sort)
    echo
    echo deps:
    for k in "${sorted_keys[@]}"; do echo "- \${deps[$k]} = ${deps[$k]}"; done
  fi

}

# :command.user_lib
# src/lib/send_completions.sh
send_completions() {
  echo $'# lep completion                                           -*- shell-script -*-'
  echo $''
  echo $'# This bash completions script was generated by'
  echo $'# completely (https://github.com/dannyben/completely)'
  echo $'# Modifying it manually is not recommended'
  echo $''
  echo $'_lep_completions_filter() {'
  echo $'  local words="$1"'
  echo $'  local cur=${COMP_WORDS[COMP_CWORD]}'
  echo $'  local result=()'
  echo $''
  echo $'  if [[ "${cur:0:1}" == "-" ]]; then'
  echo $'    echo "$words"'
  echo $'  '
  echo $'  else'
  echo $'    for word in $words; do'
  echo $'      [[ "${word:0:1}" != "-" ]] && result+=("$word")'
  echo $'    done'
  echo $''
  echo $'    echo "${result[*]}"'
  echo $''
  echo $'  fi'
  echo $'}'
  echo $''
  echo $'_lep_completions() {'
  echo $'  local cur=${COMP_WORDS[COMP_CWORD]}'
  echo $'  local compwords=("${COMP_WORDS[@]:1:$COMP_CWORD-1}")'
  echo $'  local compline="${compwords[*]}"'
  echo $''
  echo $'  case "$compline" in'
  echo $'    \'completions\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_lep_completions_filter "--help -h")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'automation\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_lep_completions_filter "--ag1 --debug --force --help --m4a --no-default-releasedate --polestar --skip-auphonic --skip-aws --skip-blogpost --skip-download --skip-ftp --skip-youtube --time -h -m")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'auphonic\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_lep_completions_filter "--cover_url --description --file --help --no-start --preset --production_name --slug -c -d -f -h -n -p -s")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'download\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_lep_completions_filter "--file --help -f -h")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'metadata\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_lep_completions_filter "--debug --help --no-default-postnumber --no-default-releasedate --title -h -t")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'blogpost\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_lep_completions_filter "--ag1 --help --number --polestar --publish_date --slug --title -h -n -p -s -t")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'youtube\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_lep_completions_filter "--help --publish_date --title -h -p -t")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'check\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_lep_completions_filter "--help --skip-youtube -h")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'init\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_lep_completions_filter "--help -h")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'ftp\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_lep_completions_filter "--file --help --name -f -h -n")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'cb\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_lep_completions_filter "--ag1 --help --number --polestar --publish_date --slug --title -h -n -p -s -t")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'a\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_lep_completions_filter "--cover_url --description --file --help --no-start --preset --production_name --slug -c -d -f -h -n -p -s")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    *)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_lep_completions_filter "--help --version -h -v a auphonic automation blogpost cb check completions download ftp init metadata youtube")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'  esac'
  echo $'} &&'
  echo $'complete -F _lep_completions lep'
  echo $''
  echo $'# ex: filetype=sh'
}

# src/lib/validations/validate_dir_exists.sh
validate_dir_exists() {
  [[ -d "$1" ]] || echo "must be an existing directory"
}

# src/lib/validations/validate_file_exists.sh
validate_file_exists() {
  [[ -f "$1" ]] || echo "must be an existing file"
}

# src/lib/validations/validate_integer.sh
validate_integer() {
  [[ "$1" =~ ^[0-9]+$ ]] || echo "must be an integer"
}

# src/lib/validations/validate_not_empty.sh
validate_not_empty() {
  [[ -z "$1" ]] && echo "must not be empty"
}

# :command.command_functions
# :command.function
lep_completions_command() {
  # src/completions_command.sh
  # Call the `send_completions` function which was added by running:
  #
  #   $ bashly add completions
  #
  # Users can now enable bash completion for this script by running:
  #
  #   $ eval "$(lep completions)"
  #
  send_completions

}

# :command.function
lep_init_command() {
  # src/init_command.sh
  folder=$(basename "$(pwd)")
  touch "$folder.md"
  window=$(tmux display-message -p '#I')
  tmux rename-window -t Aufnahmen:$window $folder
  fish -c "vim $folder.md"

}

# :command.function
lep_edit_command() {
  # src/edit_command.sh
  folder=$(basename "$(pwd)")
  nvim "$folder.md"

}

# :command.function
lep_new_command() {
  # src/new_command.sh
  #!/bin/bash

  baseName=$(basename "$(pwd)")
  newBaseName=$(basename "$(pwd)")
  episode="$baseName.m4a"
  counter=1
  latestCounter=1

  while [ -e "$episode" ]; do
      episode="$baseName-$counter.m4a"
      latestCounter=$counter
      ((counter++))
  done

  cp "$baseName.md" "$baseName-$latestCounter.md"
  cp "$baseName.txt" "$latestCounter.txt"
  cp "$baseName.png" "$latestCounter.png"

}

# :command.function
lep_check_command() {
  # src/check_command.sh
  skipYoutube=${args[--skip-youtube]}

  folder=$(basename "$(pwd)")
  episode=$folder
  error=0
  counter=1

  while [ -e "$folder-$counter.m4a" ]; do
      episode="$folder-$counter"
      ((counter++))
  done

  echo "Checking for $episode.m4a"

  if [[ $episode =~ [Ã¶Ã¼Ã¤Ã–ÃœÃ„] ]]; then
    echo -e "\e[31mîª‡ Episode title contains Umlaute \e[0m"
    error=1
  else
    echo -e "\e[32mï˜ Episode title does not have Umlaute\e[0m"
  fi

  if [[ -e "$episode.m4a" ]]; then
      echo -e "\e[32mï˜ Episode is already exported\e[0m"
  else

      echo -e "\e[31mîª‡ No Episode is exported to automate\e[0m"
      error=1
  fi

  if [[ -e "${episode}_adfree.m4a" ]]; then
      echo -e "\e[32mï˜ Adfree Episode is already exported\e[0m"
  else
      echo -e "\e[33mï± No Adfree Episode \e[0m"
  fi

  if [[ -e "$episode.md" ]]; then
      echo -e "\e[32mï˜ Episode description exists\e[0m"
  else

      echo -e "\e[31mîª‡ No Episode description available\e[0m"
      error=1
  fi

  if [[ -s "$episode.md" ]]; then
      echo -e "\e[32mï˜ Episode description is not empty\e[0m"
  else

      echo -e "\e[31mîª‡ Episode description is empty\e[0m"
      error=1
  fi

  if [[ -e "$episode.png" ]]; then
      echo -e "\e[32mï˜ Episode thumbnail exists\e[0m"
  else

      echo -e "\e[31mîª‡ No Episode thumbnail available\e[0m"
      error=1
  fi

  if [[ -z "$skipYoutube" ]]; then
      if [[ -e "${episode}_youtube.png" ]]; then
          echo -e "\e[32mï˜ Episode youtube thumbnail exists\e[0m"
      else

          echo -e "\e[31mîª‡ No Episode youtube thumbnail available\e[0m"
          error=1
      fi
  fi

  if [[ -e "$episode.chapters.txt" ]]; then
      echo -e "\e[32mï˜ Episode chapters exists\e[0m"
  else

      echo -e "\e[31mîª‡ No Episode chapters available\e[0m"
      error=1
  fi

  exit $error

}

# :command.function
lep_download_command() {
  # src/download_command.sh
  file=${args[--file]}
  folder=$(echo $file | awk -F '_' '{print $2}' | cut -d '.' -f 1)

  curl https://rssfeed.laufendentdecken-podcast.at/data/$file --output ~/Dropbox/Resources/Podcast/Aufnahmen/$folder/$file

}

# :command.function
lep_metadata_command() {
  # src/metadata_command.sh
  title=${args[--title]}
  debug=${args[--debug]}
  noDefaultReleaseDate=${args[--no-default-releasedate]}
  noDefaultPostNumber=${args[--no-default-postnumber]}

  dataFile="$title.txt"
  contentFile="$title.html"
  sourceFile="$title.md"

  if ! [[ -e $contentFile ]]; then
      echo "î˜Ž Generating html content file"
      pandoc -s -o $contentFile $sourceFile > /dev/null
  fi

  if ! [[ -e $dataFile ]]; then

      if [[ -n "$noDefaultPostNumber" ]] then
          read -p "Release number: " postNumber
      else
          postNumber=$(op read "op://Podcast/Podcast/Episode")
          postNumber=$(expr $postNumber + 1)

          if [[ -z "$debug" ]]; then
              op item edit --vault Podcast 'Podcast' 'Episode='$postNumber > /dev/null
          fi

      fi

      echo
      option=$(gum choose --header "Title Template" "GesprÃ¤ch" "Wiedersehen" "Custom")

      case $option in
          "GesprÃ¤ch")
              postTitle="Ein GesprÃ¤ch mit "
              ;;
          "Wiedersehen")
              postTitle="Ein Wiedersehen mit "
              ;;
          "Custom")
              postTitle=""
              ;;
      esac

      if [[ -n "$postTitle" ]]; then
          name=$(echo $title | sed 's/\([a-z]\)\([A-Z]\)/\1 \2/g')
          postTitle=$postTitle$name
      else
          read -p "Custom title: " postTitle
      fi

      if [[ -n "$noDefaultReleaseDate" ]] then
          while true; do
              read -p "Release Date:  " postDate

              if [[ "$postDate" =~ ^[0-9]{4}-[0-9]{2}-[0-9]{2}$ ]]; then
                  break

              fi
          done
      else

          postDate=$(date -v+friday '+%Y-%m-%d')

      fi

      echo "$postNumber,$postTitle,$postDate" >> $dataFile
  fi

  IFS=',' read -r postNumber postTitle postDate <<< "$(head -n 1 "$title"".txt")"

}

# :command.function
lep_youtube_command() {
  # src/youtube_command.sh
  #!/bin/bash

  PUBLISH_DATE=$(date -jf "%Y-%m-%d %H:%M:%S" "${args[--publish_date]}" "+%Y-%m-%dT%H:%M:%S%z")
  DESCRIPTION=${args[--title]}

  API_KEY=$(op read "op://Podcast/Youtube/credential")

  local length="${#DESCRIPTION}"
  local result=''

  for ((i = 0; i < length; i++)); do
      local char="${DESCRIPTION:i:1}"
      case $char in
          [a-zA-Z0-9.~_-])
              result+="$char"
              ;;
          *)
              printf -v hex '%%%02X' "'$char"
              result+="$hex"
              ;;
      esac
  done

  # Set the necessary scopes for the API request
  SCOPES="https://www.googleapis.com/auth/youtube.force-ssl"

  client_id=$(op read "op://Podcast/Youtube/client_id")
  client_secret=$(op read "op://Podcast/Youtube/client_secret")
  refresh_token=$(op read "op://Podcast/Youtube/refresh_token")

  # Get the access token
  ACCESS_TOKEN=$(curl -s -X POST "https://oauth2.googleapis.com/token" \
                      -H "Content-Type: application/x-www-form-urlencoded" \
                      -d "client_id=$client_id&client_secret=$client_secret&refresh_token=$refresh_token&grant_type=refresh_token" \
                      | jq -r '.access_token')

  # Send a request to the YouTube Data API to search for the video
  JSON=$(curl -s "https://www.googleapis.com/youtube/v3/search?key=$API_KEY&q=$result&part=id&part=snippet&maxResults=1&type=video&forMine=true" \
      --header "Authorization: Bearer $ACCESS_TOKEN" \
      --header 'Accept: application/json' \
  )

  # Parse the JSON response to extract the video ID
  VIDEO_ID=$(echo "$JSON" | jq -r '.items[0].id.videoId')

  REQUEST_BODY=$(jq -n --arg videoId "$VIDEO_ID" --arg date $PUBLISH_DATE '{ id: $videoId, status: { privacyStatus: "private", "publishAt": $date , "license": "youtube", "publicStatsViewable": true } }')

  # Make the API request to update the video
  SCHEDULE_RESPONSE=$(curl -s -X PUT "https://youtube.googleapis.com/youtube/v3/videos?part=status" \
      --header "Authorization: Bearer $ACCESS_TOKEN" \
      --header 'Accept: application/json' \
      --header 'Content-Type: application/json' \
      --data "$REQUEST_BODY")

  echo "ï…¦ Youtube Video has been scheduled"

}

# :command.function
lep_ftp_command() {
  # src/ftp_command.sh
  file=${args[--file]}
  name=${args[--name]}

  server_pwd=$(op read "op://Podcast/ahvoh5qmumxyrtvih2klge7uqa/credential")
  server_username=$(op read "op://Podcast/ahvoh5qmumxyrtvih2klge7uqa/username")

  curl --user $server_username:$server_pwd --upload-file $file ftp://rssfeed.laufendentdecken-podcast.at/$name

}

# :command.function
lep_upload_youtube_command() {
  # src/upload_youtube_command.sh
  defaultAirTime="09:00:00"
  episode=$(basename "$(pwd)")
  episode="$episode.m4a"

  baseUrl="https://rssfeed.laufendentdecken-podcast.at/data/"
  title=$(echo "$episode" | cut -d'.' -f 1)

  IFS=',' read -r postNumber postTitle postDate <<< "$(head -n 1 "$title"".txt")"

  coverYoutube="$title"_youtube.png
  coverYoutubeWithPostNumber="$postNumber"_"$coverYoutube"
  coverUrlYoutube="$baseUrl$coverYoutubeWithPostNumber"

  slug="$postNumber"_"$title"
  youtubePreset=$(op read "op://Podcast/Auphonic Api/youtubePreset")

  youtubeDescription=$(echo -e "\n\nHÃ¶rt rein auf:\nðŸ”—Https://laufendentdecken.at/$postNumber/\n\nUnd natÃ¼rlich auf\nðŸŽ§Spotify, iTunes, Google Podcast, zencastr und in allen podcatchern Ã¼ber das RSS Feed.\n\nâœ… Folge uns auf Instagram @laufendentdeckenpodcast , @floderandere und @redendentdecken\n\nUnd auf Facebook https://www.facebook.com/laufendentdeckenpodcast/\n\nWer uns unterstÃ¼tzen mag: https://www.patreon.com/laufendentdecken\noder Steady: https://steadyhq.com/de/laufendentdecken")
  episodeWithPostNumber="$postNumber"_"$episode"

  echo "â–ˆâ–ˆâ•—     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—      â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•—     â–ˆâ–ˆâ•—";
  echo "â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—    â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘";
  echo "â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•    â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘";
  echo "â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•”â•â•â•  â–ˆâ–ˆâ•”â•â•â•â•     â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘";
  echo "â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘         â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘";
  echo "â•šâ•â•â•â•â•â•â•â•šâ•â•â•â•â•â•â•â•šâ•â•          â•šâ•â•â•â•â•â•â•šâ•â•â•â•â•â•â•â•šâ•â•";
  echo "                                               ";

  lep check

  if [ $? -ne 0 ]; then
    exit 1
  fi

  echo "ïƒ®  Upload youtube cover to FTP Server"
  lep ftp --file $coverYoutube --name $coverYoutubeWithPostNumber

  if [ $? -ne 0 ]; then
    exit 1
  fi

  echo "ï‹Ž Automate episode 'LEP#$postNumber - $postTitle' scheduled for $postDate"

  lep auphonic  \
      --production_name "LEP#$postNumber - $postTitle" \
      --preset $youtubePreset \
      --cover_url $coverUrlYoutube \
      --file $episodeWithPostNumber \
      --slug $slug \
      --description "$youtubeDescription"

  if [ $? -ne 0 ]; then
    exit 1
  fi

  echo
  echo "ï…¦ Schedule youtube video"
  lep youtube \
      --title "LEP#$postNumber" \
      --publish_date "$postDate $defaultAirTime"

}

# :command.function
lep_automation_command() {
  # src/automation_command.sh
  skipFtp=${args[--skip-ftp]}
  skipAws=${args[--skip-aws]}
  skipAuphonic=${args[--skip-auphonic]}
  skipDownload=${args[--skip-download]}
  skipBlogpost=${args[--skip-blogpost]}
  skipYoutube=${args[--skip-youtube]}
  #skipYoutube="skip-per-default"
  force=${args[--force]}
  noDefaultReleaseDate=${args[--no-default-releasedate]}
  noDefaultPostNumber=${args[--no-default-postnumber]}

  defaultAirTime=${args[--time]}

  ag1=${args[--ag1]}
  polestar=${args[--polestar]}
  debug=${args[--debug]}

  episode=${args[--m4a]}
  if [[ -z "$episode" ]]; then
      episode=$(basename "$(pwd)")
      episode="$episode.m4a"
  fi

  echo "â–ˆâ–ˆâ•—     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—      â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•—     â–ˆâ–ˆâ•—";
  echo "â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—    â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘";
  echo "â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•    â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘";
  echo "â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•”â•â•â•  â–ˆâ–ˆâ•”â•â•â•â•     â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘";
  echo "â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘         â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘";
  echo "â•šâ•â•â•â•â•â•â•â•šâ•â•â•â•â•â•â•â•šâ•â•          â•šâ•â•â•â•â•â•â•šâ•â•â•â•â•â•â•â•šâ•â•";
  echo "                                               ";

  if [[ -z "$force" ]]; then
      if [[ -z "$skipYoutube" ]]; then
          lep check
      else

          lep check --skip-youtube
      fi
  fi

  if [ $? -ne 0 ]; then
    exit 1
  fi

  echo "ï‹Žó°€‚Start automatic workflow for file $episode"

  title=$(echo "$episode" | cut -d'.' -f 1)
  ad=$(([ -n "$ag1" ] || [ -n "$polestar" ]) && echo "true" || echo "false")

  if [[ -e "$title"_adfree.m4a ]] && [[ "$ad" = "false" ]]; then
      option=$(gum choose --header "Adfree version detected, but no advertisement provided" "AG1" "Polestar")
      case $option in
          "AG1")
              ag1="1"
              ;;
          "Polestar")
              polestar="1"
              ;;
      esac
      ad="true"
  fi

  if [[ -n "$debug" ]]; then
      if [[ -n "$noDefaultReleaseDate" ]]; then
          if [[ -n "$noDefaultPostNumber" ]]; then
              lep metadata --title $title --debug --no-default-releasedate --no-default-postnumber

          else

              lep metadata --title $title --debug --no-default-releasedate

          fi
      else

          if [[ -n "$noDefaultPostNumber" ]]; then
              lep metadata --title $title --debug --no-default-postnumber

          else

              lep metadata --title $title --debug

          fi
      fi
  else

      if [[ -n "$noDefaultReleaseDate" ]]; then
          if [[ -n "$noDefaultPostNumber" ]]; then
              lep metadata --title $title --no-default-releasedate --no-default-postnumber

          else

              lep metadata --title $title --no-default-releasedate

          fi
      else

          if [[ -n "$noDefaultPostNumber" ]]; then
              lep metadata --title $title --no-default-postnumber

          else

              lep metadata --title $title

          fi
      fi
  fi

  IFS=',' read -r postNumber postTitle postDate <<< "$(head -n 1 "$title"".txt")"

  echo "ï‹Ž Automate episode 'LEP#$postNumber - $postTitle' scheduled for $postDate"

  chapters=$(<"$title".chapters.txt)
  cover="$title".png

  if [[ "$ad" = "true" ]]; then
      episodeAdFree="$title"_adfree.m4a
      titleAdFree="$title"_adfree
  else
      episodeAdFree=$episode
      titleAdFree=$title
  fi

  coverYoutube="$title"_youtube.png
  baseUrl="https://rssfeed.laufendentdecken-podcast.at/data/"

  coverWithPostNumber="$postNumber"_"$cover"
  coverYoutubeWithPostNumber="$postNumber"_"$coverYoutube"

  coverUrl="$baseUrl$coverWithPostNumber"
  coverUrlYoutube="$baseUrl$coverYoutubeWithPostNumber"

  episodeWithPostNumber="$postNumber"_"$episode"
  episodeAdFreeWithPostNumber="$postNumber"_"$episodeAdFree"
  slug="$postNumber"_"$title"
  slugAdFree="$postNumber"_"$titleAdFree"

  if [[ -z "$skipFtp" ]]; then
      echo
      echo "ïƒ®  Upload episode to FTP Server"
      lep ftp --file $episode --name $episodeWithPostNumber

      if [[ "$ad" = "true" ]]; then
          echo "ïƒ®  Upload adfree episode to FTP Server"
          lep ftp --file $episodeAdFree --name $episodeAdFreeWithPostNumber
      fi

      echo "ïƒ®  Upload cover to FTP Server"
      lep ftp --file $cover --name $coverWithPostNumber

      if [[ -z "$skipYoutube" ]]; then
          echo "ïƒ®  Upload youtube cover to FTP Server"
          lep ftp --file $coverYoutube --name $coverYoutubeWithPostNumber

      fi
  fi

  if [ $? -ne 0 ]; then
    exit 1
  fi

  if [[ -z "$skipAws" ]]; then
      echo
      echo "î‰ Backup to S3"

      aws s3 cp $episode s3://laufendentdecken-podcast/$episodeWithPostNumber
      aws s3 cp s3://laufendentdecken-podcast/$episodeWithPostNumber s3://laufendentdecken-podcast-backup/

      if [[ "$ad" = "true" ]]; then
          aws s3 cp $episodeAdFree s3://laufendentdecken-podcast/$episodeAdFreeWithPostNumber
          aws s3 cp s3://laufendentdecken-podcast/$episodeAdFreeWithPostNumber s3://laufendentdecken-podcast-backup/
      fi
  fi

  if [ $? -ne 0 ]; then
    exit 1
  fi

  if [[ -z "$skipAuphonic" ]]; then
      episodePreset=$(op read "op://Podcast/Auphonic Api/episodePreset")

      youtubePreset=$(op read "op://Podcast/Auphonic Api/youtubePreset")

      description=$(pbpaste | tr '\n' ' ')
      youtubeDescription=$(echo -e "${description}\n\nHÃ¶rt rein auf:\nðŸ”—Https://laufendentdecken.at/$postNumber/\n\nUnd natÃ¼rlich auf\nðŸŽ§Spotify, iTunes, Google Podcast, zencastr und in allen podcatchern Ã¼ber das RSS Feed.\n\nâœ… Folge uns auf Instagram @laufendentdeckenpodcast , @floderandere und @redendentdecken\n\nUnd auf Facebook https://www.facebook.com/laufendentdeckenpodcast/\n\nWer uns unterstÃ¼tzen mag: https://www.patreon.com/laufendentdecken\noder Steady: https://steadyhq.com/de/laufendentdecken")

      lep auphonic  \
          --production_name $title \
          --preset $episodePreset\
          --cover_url $coverUrl \
          --file $episodeWithPostNumber \
          --slug $slug

      if [[ -z "$skipYoutube" ]]; then
          lep auphonic  \
              --production_name "LEP#$postNumber - $postTitle" \
              --preset $youtubePreset \
              --cover_url $coverUrlYoutube \
              --file $episodeWithPostNumber \
              --slug $slug \
              --description "$youtubeDescription"
      fi

      if [[ "$ad" = "true" ]]; then
          lep auphonic  \
              --production_name "$title (adfree)" \
              --preset $episodePreset \
              --cover_url $coverUrl \
              --file $episodeAdFreeWithPostNumber \
              --slug $slug
      fi

      echo "ï…Š Podcast successfully uploaded"
  fi

  if [ $? -ne 0 ]; then
    exit 1
  fi

  if [[ -z "$skipDownload" ]]; then
      echo
      echo "î«‚ Download adfree version again to be able to upload it to patroen/steady"
      lep download --file "$slugAdFree.mp3"

  fi

  if [ $? -ne 0 ]; then
    exit 1
  fi

  if [[ -z "$skipBlogpost" ]]; then
      echo
      echo "î¬†ó°œCreate Episode on Website"

      if [[ "$ad" = "false" ]]; then
          lep blogpost \
              --number $postNumber \
              --title "$postTitle" \
              --publish_date "$postDate $defaultAirTime" \
              --slug $slug
      fi

      if [[ -n "$ag1" ]]; then
          lep blogpost \
              --number $postNumber \
              --title "$postTitle" \
              --publish_date "$postDate $defaultAirTime" \
              --slug $slug \
              --ag1
      fi

      if [[ -n "$polestar" ]]; then
          lep blogpost \
              --number $postNumber \
              --title "$postTitle" \
              --publish_date "$postDate $defaultAirTime" \
              --slug $slug \
              --polestar
      fi

  fi

  if [[ -z "$skipYoutube" ]]; then
      echo
      echo "ï…¦ Schedule youtube video"
      lep youtube \
          --title "LEP#$postNumber" \
          --publish_date "$postDate $defaultAirTime"
  fi

}

# :command.function
lep_auphonic_command() {
  # src/auphonic_command.sh
  title=${args[--slug]}
  episode=${args[--file]}
  coverUrl=${args[--cover_url]}
  auphonicTitle=${args[--production_name]}
  preset=${args[--preset]}
  noStart=${args[--no-start]}
  description=${args[--description]}

  name=$(echo "${title#*_}")
  chapters=$(<"$name".chapters.txt)

  auphonic_pwd=$(op read "op://Podcast/Auphonic Api/credential")

  auphonic_username=$(op read "op://Podcast/Auphonic Api/username")

  action="start"

  if [[ -n "$noStart" ]]; then
      action="save"
  fi

  echo
  echo "ï‡‡ Create $auphonicTitle Production"
  json=$(curl -s -X POST https://auphonic.com/api/simple/productions.json \
       -u $auphonic_username:$auphonic_pwd \
       -F "preset=$preset" \
       -F "service=Tz96q8s6vs7JetJeqD6PCC" \
       -F "title=$auphonicTitle" \
       -F "track=$title" \
       -F "chapters=$chapters" \
       -F "input_file=$episode" \
       -F "image=$coverUrl" \
       -F "summary=$description" \
       -F "action=$action")

  if [[ -z "$noStart" ]]; then
      echo "î«“ Production started"
      content=$(echo $json | jq -r ' . | "\(.data.status_string):\(.data.uuid)"')
      IFS=':' read -ra response <<< "$content"

      status_string=${response[0]}
      uuid=${response[1]}

      echo "UUID: $uuid"
      echo -ne "Auphonic status: $status_string \r"

      while [[ $status_string != "Done"  ]]
      do
          json=$(curl -s -X GET https://auphonic.com/api/production/$uuid.json \
              -u $auphonic_username:$auphonic_pwd)

          status_string=$(echo $json | jq -r ' . | .data.status_string')

          echo -ne "Auphonic status: $status_string                         \r"
          sleep 2
      done
  else
      echo "î­‰ Production $auphonicTitle saved"
  fi

}

# :command.function
lep_blogpost_command() {
  # src/blogpost_command.sh
  postNumber=${args[--number]}
  postTitle=${args[--title]}
  postDate=${args[--publish_date]}
  slug=${args[--slug]}

  ag1=${args[--ag1]}
  polestar=${args[--polestar]}

  fullPostTitle="LEP#$postNumber - $postTitle"

  title=$(echo "${slug#*_}")
  name=$(echo $title | sed 's/\([a-z]\)\([A-Z]\)/\1 \2/g')
  contentHtml="$title".html

  image="$title".png

  if  [[ -e $contentHtml ]]; then
      description=$(sed -n '/<body/,/<\/body>/p' $contentHtml | sed '1d;$d' |  sed 's/"/''/g' | tr '\n' ' ')
  else
      description=""
  fi

  while true; do
      seoMetaDescription=$(ollama run mistral "Act as an seo expert and assist me in writing an SEO meta-description. Please provide your answer in german, not english. What I need from you is exactly one sentence (not longer) that summarizes the input: $(cat $title.md). Please don't use more then 50 words'")
      echo "Generated seo meta-description: $seoMetaDescription"
      gum confirm --selected.background=2 --selected.foreground=0 "Ok ?"

      if [ $? -eq 0 ]; then
          break
      fi
  done

  case $postTitle in
      "Ein GesprÃ¤ch mit "*)
          guest=${postTitle#"Ein GesprÃ¤ch mit "}
          guest="<b>Links zum weiterlesen</b><br><br>Mehr Informationen zu $guest:Â Instagram | Facebook <br><br>"
          ;;

      "Ein Wiedersehen mit "*)
          guest=${postTitle#"Ein Wiedersehen mit "}
          guest="<b>Links zum weiterlesen</b><br><br>Mehr Informationen zu $guest:Â Instagram | Facebook <br><br>"
          ;;
      *)
          guest=""
          ;;
  esac

  content="<b>Werbefrei</b><br><br>ZusÃ¤tzlich habt ihr ab sofort die MÃ¶glichkeit euch das exklusive <a href='https://www.patreon.com/laufendentdecken'>Patreonfeed</a> zu sichern â€“ werbefrei und liebevoll exportiert.<br><br>Am besten direkt mitmachen und unterstÃ¼tzen: <a href='https://www.patreon.com/laufendentdecken'>Patreon</a><br><br>${guest}Wenn ihr den Podcast direkt ohne Installation hÃ¶ren mÃ¶chtet, kÃ¶nnt ihr das hier tun: Laufend Entdecken auf Podbay<br><br>Florian:Â <a href='http://twitter.com/laufenentdecken'>Twitter</a>,Â <a href='https://www.strava.com/athletes/1651823'>Strava</a><br>Peter:Â <a href='https://twitter.com/redendentdecken'>Twitter</a>,Â <a href='https://www.instagram.com/redendentdecken'>Instagram</a>,Â <a href='https://www.strava.com/athletes/24464941'>Strava</a><br>Geordi:Â <a href='https://twitter.com/Geordi2504'>Twitter</a>,Â <a href='https://www.instagram.com/geordi2504/'>Instagram</a>,Â <a href='https://www.instagram.com/viennarunning/'>Vienna Running Instagram</a>,Â <a href='https://vienna-running.eu/'>Vienna Running</a><br><br><a href='http://facebook.com/laufendentdeckenblog/'>Facebook</a>,Â <a href='https://instagram.com/laufendentdeckenpodcast/'>Instagram</a>,Â <a href='https://www.strava.com/clubs/473847'>Strava Club</a>"

  if [[ -n "$ag1" ]]; then
      content="<b>Werbung</b><br><br>Informiere dich jetzt auf <a href='http://drinkag1.com/laufendentdecken'>drinkag1.com/laufendentdecken</a> , teste AG1 vÃ¶llig risikofrei mit 90 Tagen Geld-zurÃ¼ck-Garantie und sichere dir bei deiner AG1 Erstbestellung einen kostenlosen Jahresvorrat an Vitamin D3+K2 zur UnterstÃ¼tzung des Immunsystems & 5 praktische Travel Packs! Gesundheitsbezogene Angaben zu AG1 und unser Angebot findest du auf: <a href='http://drinkag1.com/laufendentdecken'>drinkag1.com/laufendentdecken</a><br><br>Auf die Bedeutung einer abwechslungsreichen und ausgewogenen ErnÃ¤hrung und einer gesunden Lebensweise wird hingewiesen. AuÃŸer Reichweite von Kindern aufbewahren. Nicht geeignet fÃ¼r Kinder und Jugendliche unter 18 Jahren, schwangere oder stillende Frauen. Die angegebene empfohlene tÃ¤gliche Verzehrmenge darf nicht Ã¼berschritten werden.<br><br>$content"
  fi

  if [[ -n "$polestar" ]]; then
      content="<b>Werbung</b><br><br>Alle Informationen zur Aktion von <a href='https://www.polestar.com/at/'>Polestar</a> findest du unter: <a href='https://www.polestar.com/at/polestar-2-2023/'>https://www.polestar.com/at/polestar-2-2023/</a><br>Das Leasingangebot ist gÃ¼ltig bis 30.06.2023<br><br>$content"
  fi

  apiKey=$(op read "op://Podcast/Podlove/credential")

  echo "î®¼ Initiating episode"

  json=$(curl -s -X POST https://laufendentdecken-podcast.at/wp-json/podlove/v2/episodes \
      --header "Authorization: Basic $apiKey")

  episodeId=$(echo $json | jq -r ' . | "\(.id)"')
  response=$(curl -s -X POST https://laufendentdecken-podcast.at/wp-json/podlove/v2/episodes/$episodeId \
      --header "Authorization: Basic $apiKey" \
      --header 'Content-Type: application/json; charset=utf-8' \
      -d "{ \"slug\": \"$slug\", \"title\": \"$fullPostTitle\", \"number\": \"$postNumber\" }")

  json=$(curl -s -X GET https://laufendentdecken-podcast.at/wp-json/podlove/v2/episodes/$episodeId --header "Authorization: Basic $apiKey")
  postId=$(echo $json | jq -r ' . | "\(.post_id)"')

  echo "ï€¾ Uploading feature image"

  featureMedia=$(curl --request POST \
      --url https://laufendentdecken-podcast.at/wp-json/wp/v2/media \
      --http1.1 \
      --header "authorization: Basic ${apiKey}" \
      --header 'content-type: multipart/form-data' \
      --form "file=@${image}" \
      --form "title=$name" \
      | jq -r '.id')

  postData="{ \"yoast_wpseo_metadesc\": $seoMetaDescription, \"featured_media\": $featureMedia, \"title\":\"$fullPostTitle\", \"status\": \"future\", \"date\": \"$postDate\", \"slug\": \"$postNumber\", \"content\": \"<!-- wp:paragraph -->$description<!-- /wp:paragraph --> <!-- wp:paragraph -->$content<!-- /wp:paragraph -->\" }"

  echo "îŠˆ Updating information"

  response=$(curl --silent -X POST https://laufendentdecken-podcast.at/wp-json/wp/v2/episodes/$postId \
      --header "Authorization: Basic $apiKey" \
      --header 'Content-Type: application/json; charset=utf-8' \
      --data-raw "$postData")

  echo "ï‡‡ Setting Assets"
  m4a=$(curl -s -X PUT https://laufendentdecken-podcast.at/wp-json/podlove/v2/episodes/$episodeId/media/2/enable --header "Authorization: Basic $apiKey")
  mp3=$(curl -s -X PUT https://laufendentdecken-podcast.at/wp-json/podlove/v2/episodes/$episodeId/media/3/enable --header "Authorization: Basic $apiKey")

  filename="$title.chapters.txt"
  json="{ \"chapters\": ["

  while IFS= read -r line || [[ -n "$line" ]]; do
      start="${line%% *}"
      start="${start%%.*}"

      title="${line#* }"

      json+="{\"start\": \"$start\", \"title\": \"$title\"},"
  done < "$filename"

  json=${json%?}

  json+="]}"

  echo "îª¤ Chapter"
  chapters=$(curl -s -X PUT https://laufendentdecken-podcast.at/wp-json/podlove/v2/chapters/$episodeId \
      --header "Authorization: Basic $apiKey" \
      --header 'accept: application/json' \
      --header 'content-type: application/json; charset=utf-8' \
      --data-raw "$json")

}

# :command.parse_requirements
parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --version | -v)
        version_command
        exit
        ;;

      --help | -h)
        long_usage=yes
        lep_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.dependencies_filter
  if command -v aws >/dev/null 2>&1; then
    deps['aws']="$(command -v aws | head -n1)"
  else
    printf "missing dependency: aws\n" >&2
    printf "%s\n" "install by running: 'brew install awscli'" >&2
    exit 1
  fi

  if command -v op >/dev/null 2>&1; then
    deps['op']="$(command -v op | head -n1)"
  else
    printf "missing dependency: op\n" >&2
    printf "%s\n" "install by running: 'brew install 1password-cli'" >&2
    exit 1
  fi

  if command -v jq >/dev/null 2>&1; then
    deps['jq']="$(command -v jq | head -n1)"
  else
    printf "missing dependency: jq\n" >&2
    printf "%s\n" "install by running: 'brew install jq'" >&2
    exit 1
  fi

  if command -v gum >/dev/null 2>&1; then
    deps['gum']="$(command -v gum | head -n1)"
  else
    printf "missing dependency: gum\n" >&2
    printf "%s\n" "install by running: 'brew install gum'" >&2
    exit 1
  fi

  if command -v ollama >/dev/null 2>&1; then
    deps['ollama']="$(command -v ollama | head -n1)"
  else
    printf "missing dependency: ollama\n" >&2
    printf "%s\n" "install by running: 'brew install ollama'" >&2
    exit 1
  fi

  if command -v curl >/dev/null 2>&1; then
    deps['curl']="$(command -v curl | head -n1)"
  else
    printf "missing dependency: curl\n" >&2
    printf "%s\n" "Please install curl" >&2
    exit 1
  fi

  if command -v pandoc >/dev/null 2>&1; then
    deps['pandoc']="$(command -v pandoc | head -n1)"
  else
    printf "missing dependency: pandoc\n" >&2
    printf "%s\n" "install by running: 'brew install jq'" >&2
    exit 1
  fi

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    completions)
      action="completions"
      shift
      lep_completions_parse_requirements "$@"
      shift $#
      ;;

    init)
      action="init"
      shift
      lep_init_parse_requirements "$@"
      shift $#
      ;;

    edit)
      action="edit"
      shift
      lep_edit_parse_requirements "$@"
      shift $#
      ;;

    new)
      action="new"
      shift
      lep_new_parse_requirements "$@"
      shift $#
      ;;

    check)
      action="check"
      shift
      lep_check_parse_requirements "$@"
      shift $#
      ;;

    download)
      action="download"
      shift
      lep_download_parse_requirements "$@"
      shift $#
      ;;

    metadata)
      action="metadata"
      shift
      lep_metadata_parse_requirements "$@"
      shift $#
      ;;

    youtube)
      action="youtube"
      shift
      lep_youtube_parse_requirements "$@"
      shift $#
      ;;

    ftp)
      action="ftp"
      shift
      lep_ftp_parse_requirements "$@"
      shift $#
      ;;

    upload-youtube)
      action="upload-youtube"
      shift
      lep_upload_youtube_parse_requirements "$@"
      shift $#
      ;;

    automation)
      action="automation"
      shift
      lep_automation_parse_requirements "$@"
      shift $#
      ;;

    auphonic | a)
      action="auphonic"
      shift
      lep_auphonic_parse_requirements "$@"
      shift $#
      ;;

    blogpost | cb)
      action="blogpost"
      shift
      lep_blogpost_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      lep_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
lep_completions_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        lep_completions_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="completions"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
lep_init_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        lep_init_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="init"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
lep_edit_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        lep_edit_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="edit"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
lep_new_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        lep_new_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="new"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
lep_check_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        lep_check_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="check"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --skip-youtube)

        # :flag.case_no_arg
        args['--skip-youtube']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
lep_download_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        lep_download_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="download"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --file | -f)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--file']="$2"
          shift
          shift
        else
          printf "%s\n" "--file requires an argument: --file, -f FILE" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

  # :command.required_flags_filter
  if [[ -z ${args['--file']+x} ]]; then
    printf "missing required flag: --file, -f FILE\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
lep_metadata_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        lep_metadata_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="metadata"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --title | -t)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--title']="$2"
          shift
          shift
        else
          printf "%s\n" "--title requires an argument: --title, -t TITLE" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --debug)

        # :flag.case_no_arg
        args['--debug']=1
        shift
        ;;

      # :flag.case
      --no-default-releasedate)

        # :flag.case_no_arg
        args['--no-default-releasedate']=1
        shift
        ;;

      # :flag.case
      --no-default-postnumber)

        # :flag.case_no_arg
        args['--no-default-postnumber']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

  # :command.required_flags_filter
  if [[ -z ${args['--title']+x} ]]; then
    printf "missing required flag: --title, -t TITLE\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
lep_youtube_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        lep_youtube_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="youtube"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --title | -t)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--title']="$2"
          shift
          shift
        else
          printf "%s\n" "--title requires an argument: --title, -t TITLE" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --publish_date | -p)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--publish_date']="$2"
          shift
          shift
        else
          printf "%s\n" "--publish_date requires an argument: --publish_date, -p PUBLISH_DATE" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

  # :command.required_flags_filter
  if [[ -z ${args['--title']+x} ]]; then
    printf "missing required flag: --title, -t TITLE\n" >&2
    exit 1
  fi
  if [[ -z ${args['--publish_date']+x} ]]; then
    printf "missing required flag: --publish_date, -p PUBLISH_DATE\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
lep_ftp_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        lep_ftp_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="ftp"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --file | -f)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--file']="$2"
          shift
          shift
        else
          printf "%s\n" "--file requires an argument: --file, -f FILE" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --name | -n)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--name']="$2"
          shift
          shift
        else
          printf "%s\n" "--name requires an argument: --name, -n NAME" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

  # :command.required_flags_filter
  if [[ -z ${args['--file']+x} ]]; then
    printf "missing required flag: --file, -f FILE\n" >&2
    exit 1
  fi
  if [[ -z ${args['--name']+x} ]]; then
    printf "missing required flag: --name, -n NAME\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
lep_upload_youtube_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        lep_upload_youtube_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="upload-youtube"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
lep_automation_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        lep_automation_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="automation"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --m4a | -m)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          # :flag.validations
          if [[ -n $(validate_file_exists "$2") ]]; then
            printf "validation error in %s:\n%s\n" "--m4a, -m M4A" "$(validate_file_exists "$2")" >&2
            exit 1
          fi

          args['--m4a']="$2"
          shift
          shift
        else
          printf "%s\n" "--m4a requires an argument: --m4a, -m M4A" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --time)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--time']="$2"
          shift
          shift
        else
          printf "%s\n" "--time requires an argument: --time TIME" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --force)

        # :flag.case_no_arg
        args['--force']=1
        shift
        ;;

      # :flag.case
      --ag1)

        # :flag.case_no_arg
        args['--ag1']=1
        shift
        ;;

      # :flag.case
      --polestar)

        # :flag.case_no_arg
        args['--polestar']=1
        shift
        ;;

      # :flag.case
      --debug)

        # :flag.case_no_arg
        args['--debug']=1
        shift
        ;;

      # :flag.case
      --no-default-releasedate)

        # :flag.case_no_arg
        args['--no-default-releasedate']=1
        shift
        ;;

      # :flag.case
      --skip-ftp)

        # :flag.case_no_arg
        args['--skip-ftp']=1
        shift
        ;;

      # :flag.case
      --skip-aws)

        # :flag.case_no_arg
        args['--skip-aws']=1
        shift
        ;;

      # :flag.case
      --skip-auphonic)

        # :flag.case_no_arg
        args['--skip-auphonic']=1
        shift
        ;;

      # :flag.case
      --skip-download)

        # :flag.case_no_arg
        args['--skip-download']=1
        shift
        ;;

      # :flag.case
      --skip-blogpost)

        # :flag.case_no_arg
        args['--skip-blogpost']=1
        shift
        ;;

      # :flag.case
      --skip-youtube)

        # :flag.case_no_arg
        args['--skip-youtube']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

  # :command.default_assignments
  [[ -n ${args['--time']:-} ]] || args['--time']="09:00:00"

}

# :command.parse_requirements
lep_auphonic_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        lep_auphonic_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="auphonic"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --production_name | -n)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--production_name']="$2"
          shift
          shift
        else
          printf "%s\n" "--production_name requires an argument: --production_name, -n PRODUCTION_NAME" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --preset | -p)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--preset']="$2"
          shift
          shift
        else
          printf "%s\n" "--preset requires an argument: --preset, -p PRESET" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --cover_url | -c)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--cover_url']="$2"
          shift
          shift
        else
          printf "%s\n" "--cover_url requires an argument: --cover_url, -c COVER_URL" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --file | -f)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--file']="$2"
          shift
          shift
        else
          printf "%s\n" "--file requires an argument: --file, -f FILE" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --slug | -s)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--slug']="$2"
          shift
          shift
        else
          printf "%s\n" "--slug requires an argument: --slug, -s SLUG" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --description | -d)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--description']="$2"
          shift
          shift
        else
          printf "%s\n" "--description requires an argument: --description, -d DESCRIPTION" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --no-start)

        # :flag.case_no_arg
        args['--no-start']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

  # :command.required_flags_filter
  if [[ -z ${args['--production_name']+x} ]]; then
    printf "missing required flag: --production_name, -n PRODUCTION_NAME\n" >&2
    exit 1
  fi
  if [[ -z ${args['--preset']+x} ]]; then
    printf "missing required flag: --preset, -p PRESET\n" >&2
    exit 1
  fi
  if [[ -z ${args['--cover_url']+x} ]]; then
    printf "missing required flag: --cover_url, -c COVER_URL\n" >&2
    exit 1
  fi
  if [[ -z ${args['--file']+x} ]]; then
    printf "missing required flag: --file, -f FILE\n" >&2
    exit 1
  fi
  if [[ -z ${args['--slug']+x} ]]; then
    printf "missing required flag: --slug, -s SLUG\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
lep_blogpost_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        lep_blogpost_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="blogpost"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --ag1)

        # :flag.case_no_arg
        args['--ag1']=1
        shift
        ;;

      # :flag.case
      --polestar)

        # :flag.case_no_arg
        args['--polestar']=1
        shift
        ;;

      # :flag.case
      --number | -n)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--number']="$2"
          shift
          shift
        else
          printf "%s\n" "--number requires an argument: --number, -n NUMBER" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --title | -t)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--title']="$2"
          shift
          shift
        else
          printf "%s\n" "--title requires an argument: --title, -t TITLE" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --publish_date | -p)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--publish_date']="$2"
          shift
          shift
        else
          printf "%s\n" "--publish_date requires an argument: --publish_date, -p PUBLISH_DATE" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --slug | -s)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--slug']="$2"
          shift
          shift
        else
          printf "%s\n" "--slug requires an argument: --slug, -s SLUG" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

  # :command.required_flags_filter
  if [[ -z ${args['--number']+x} ]]; then
    printf "missing required flag: --number, -n NUMBER\n" >&2
    exit 1
  fi
  if [[ -z ${args['--title']+x} ]]; then
    printf "missing required flag: --title, -t TITLE\n" >&2
    exit 1
  fi
  if [[ -z ${args['--publish_date']+x} ]]; then
    printf "missing required flag: --publish_date, -p PUBLISH_DATE\n" >&2
    exit 1
  fi
  if [[ -z ${args['--slug']+x} ]]; then
    printf "missing required flag: --slug, -s SLUG\n" >&2
    exit 1
  fi

}

# :command.user_hooks
before_hook() {
  # src/before.sh
  op signin --account my.1password.com

}

# :command.initialize
initialize() {
  version="1.0.0"
  long_usage=''
  set -e

  # src/initialize.sh

}

# :command.run
run() {
  declare -A args=()
  declare -A deps=()
  declare -a other_args=()
  declare -a input=()
  normalize_input "$@"
  parse_requirements "${input[@]}"
  before_hook

  case "$action" in
    "completions") lep_completions_command ;;
    "init") lep_init_command ;;
    "edit") lep_edit_command ;;
    "new") lep_new_command ;;
    "check") lep_check_command ;;
    "download") lep_download_command ;;
    "metadata") lep_metadata_command ;;
    "youtube") lep_youtube_command ;;
    "ftp") lep_ftp_command ;;
    "upload-youtube") lep_upload_youtube_command ;;
    "automation") lep_automation_command ;;
    "auphonic") lep_auphonic_command ;;
    "blogpost") lep_blogpost_command ;;
  esac
}

initialize
run "$@"
