#!/usr/bin/env bash
# This script was generated by bashly 1.0.2 (https://bashly.dannyb.co)
# Modifying it manually is not recommended

# :wrapper.bash3_bouncer
if [[ "${BASH_VERSINFO:-0}" -lt 4 ]]; then
  printf "bash version 4 or higher is required\n" >&2
  exit 1
fi

# :command.master_script

# :command.version_command
version_command() {
  echo "$version"
}

# :command.usage
lep_usage() {
  if [[ -n $long_usage ]]; then
    printf "lep - Manage the laufendentdecken podcast via terminal\n"
    echo

  else
    printf "lep - Manage the laufendentdecken podcast via terminal\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  lep COMMAND\n"
  printf "  lep [COMMAND] --help | -h\n"
  printf "  lep --version | -v\n"
  echo
  # :command.usage_commands
  printf "%s\n" "Commands:"
  printf "  %s   Configure youtube video\n" "youtube   "
  printf "  %s   Upload file to self hosted ftp server\n" "ftp       "
  printf "  %s   Upload latest episode and start automatic post processing workflow\n" "automation"
  printf "  %s   Start new auphonic production\n" "auphonic  "
  printf "  %s   Create wordpress blogpost on http://laufendentdecken-podcast.at\n" "blogpost  "
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo
    printf "  %s\n" "--version, -v"
    printf "    Show version number\n"
    echo

  fi
}

# :command.usage
lep_youtube_usage() {
  if [[ -n $long_usage ]]; then
    printf "lep youtube - Configure youtube video\n"
    echo

  else
    printf "lep youtube - Configure youtube video\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  lep youtube [OPTIONS]\n"
  printf "  lep youtube --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--title, -t TITLE (required)"
    printf "    Episode Title\n"
    echo

    # :flag.usage
    printf "  %s\n" "--publish_date, -p PUBLISH_DATE (required)"
    printf "    Publish Date\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
lep_ftp_usage() {
  if [[ -n $long_usage ]]; then
    printf "lep ftp - Upload file to self hosted ftp server\n"
    echo

  else
    printf "lep ftp - Upload file to self hosted ftp server\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  lep ftp [OPTIONS]\n"
  printf "  lep ftp --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--file, -f FILE (required)"
    printf "    File to upload\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
lep_automation_usage() {
  if [[ -n $long_usage ]]; then
    printf "lep automation - Upload latest episode and start automatic post processing workflow\n"
    echo

  else
    printf "lep automation - Upload latest episode and start automatic post processing workflow\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  lep automation [OPTIONS]\n"
  printf "  lep automation --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--m4a, -m M4A"
    printf "    Episode as m4a\n"
    echo

    # :flag.usage
    printf "  %s\n" "--ag1"
    printf "    This episodes is supportd by AG1\n"
    echo

    # :flag.usage
    printf "  %s\n" "--skip-ftp"
    printf "    Skip upload to FTP server\n"
    echo

    # :flag.usage
    printf "  %s\n" "--skip-aws"
    printf "    Skip upload to aws\n"
    echo

    # :flag.usage
    printf "  %s\n" "--skip-auphonic"
    printf "    Skip upload to Auphonic\n"
    echo

    # :flag.usage
    printf "  %s\n" "--skip-download"
    printf "    Skip download from patreon\n"
    echo

    # :flag.usage
    printf "  %s\n" "--skip-blogpost"
    printf "    Skip create blogpost\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  lep upload --m4a episode.m4a\n"
    echo

  fi
}

# :command.usage
lep_auphonic_usage() {
  if [[ -n $long_usage ]]; then
    printf "lep auphonic - Start new auphonic production\n"
    echo

  else
    printf "lep auphonic - Start new auphonic production\n"
    echo

  fi

  printf "Alias: a\n"
  echo

  printf "%s\n" "Usage:"
  printf "  lep auphonic [OPTIONS]\n"
  printf "  lep auphonic --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--production_name, -n PRODUCTION_NAME (required)"
    printf "    Auphonic production name\n"
    echo

    # :flag.usage
    printf "  %s\n" "--preset, -p PRESET (required)"
    printf "    Auphonic preset\n"
    echo

    # :flag.usage
    printf "  %s\n" "--cover_url, -c COVER_URL (required)"
    printf "    URL of the cover image\n"
    echo

    # :flag.usage
    printf "  %s\n" "--file, -f FILE (required)"
    printf "    File name of the production\n"
    echo

    # :flag.usage
    printf "  %s\n" "--slug, -s SLUG (required)"
    printf "    Slug of the auphonic production\n"
    echo

    # :flag.usage
    printf "  %s\n" "--description, -d DESCRIPTION"
    printf "    Description of the episode\n"
    echo

    # :flag.usage
    printf "  %s\n" "--no-start"
    printf "    Dont automatically start the auphonic production\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  lep auphonic --production_name episode1 --preset \"123823\" --cover_url\n  \"http://url\" --file episode1.m4a --slug episode1\n"
    echo

  fi
}

# :command.usage
lep_blogpost_usage() {
  if [[ -n $long_usage ]]; then
    printf "lep blogpost - Create wordpress blogpost on http://laufendentdecken-podcast.at\n"
    echo

  else
    printf "lep blogpost - Create wordpress blogpost on http://laufendentdecken-podcast.at\n"
    echo

  fi

  printf "Alias: cb\n"
  echo

  printf "%s\n" "Usage:"
  printf "  lep blogpost [OPTIONS]\n"
  printf "  lep blogpost --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--ag1"
    printf "    This episodes is supportd by AG1\n"
    echo

    # :flag.usage
    printf "  %s\n" "--number, -n NUMBER (required)"
    printf "    Episode Number\n"
    echo

    # :flag.usage
    printf "  %s\n" "--title, -t TITLE (required)"
    printf "    Episode Title\n"
    echo

    # :flag.usage
    printf "  %s\n" "--publish_date, -p PUBLISH_DATE (required)"
    printf "    Publish Date\n"
    echo

    # :flag.usage
    printf "  %s\n" "--slug, -s SLUG (required)"
    printf "    Slug of the auphonic production\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  lep create-blogpost --number 1 --title \"Episode Title\" --publish_date\n  \"2049-12-31\" --slug \"slug\"\n"
    echo

  fi
}

# :command.normalize_input
normalize_input() {
  local arg flags

  while [[ $# -gt 0 ]]; do
    arg="$1"
    if [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then
      flags="${BASH_REMATCH[1]}"
      for ((i = 0; i < ${#flags}; i++)); do
        input+=("-${flags:i:1}")
      done
    else
      input+=("$arg")
    fi

    shift
  done
}
# :command.inspect_args
inspect_args() {
  if ((${#args[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!args[@]}" | sort)
    echo args:
    for k in "${sorted_keys[@]}"; do echo "- \${args[$k]} = ${args[$k]}"; done
  else
    echo args: none
  fi

  if ((${#other_args[@]})); then
    echo
    echo other_args:
    echo "- \${other_args[*]} = ${other_args[*]}"
    for i in "${!other_args[@]}"; do
      echo "- \${other_args[$i]} = ${other_args[$i]}"
    done
  fi

  if ((${#deps[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!deps[@]}" | sort)
    echo
    echo deps:
    for k in "${sorted_keys[@]}"; do echo "- \${deps[$k]} = ${deps[$k]}"; done
  fi

}

# :command.user_lib
# src/lib/validations/validate_dir_exists.sh
validate_dir_exists() {
  [[ -d "$1" ]] || echo "must be an existing directory"
}

# src/lib/validations/validate_file_exists.sh
validate_file_exists() {
  [[ -f "$1" ]] || echo "must be an existing file"
}

# src/lib/validations/validate_integer.sh
validate_integer() {
  [[ "$1" =~ ^[0-9]+$ ]] || echo "must be an integer"
}

# src/lib/validations/validate_not_empty.sh
validate_not_empty() {
  [[ -z "$1" ]] && echo "must not be empty"
}

# :command.command_functions
# :command.function
lep_youtube_command() {
  # src/youtube_command.sh
  #!/bin/bash

  API_KEY=$(op item get "YoutubeApiKey" --format json | jq -r '. | .fields | .[] | select(.label=="password") | .value')

  # Set the title of the video you want to search for
  local string="LEP#125"

  local length="${#string}"
  local result=''

  for ((i = 0; i < length; i++)); do
      local char="${string:i:1}"
      case $char in
          [a-zA-Z0-9.~_-])
              result+="$char"
              ;;
          *)
              printf -v hex '%%%02X' "'$char"
              result+="$hex"
              ;;
      esac
  done

  # Send a request to the YouTube Data API to search for the video
  JSON=$(curl -s "https://www.googleapis.com/youtube/v3/search?key=$API_KEY&q=$result&part=id&part=snippet&maxResults=1&type=video")

  # Parse the JSON response to extract the video ID
  VIDEO_ID=$(echo "$JSON" | jq -r '.items[0].id.videoId')

  # Print the video ID
  echo "The video ID for \"$result\" is: $VIDEO_ID"

  # Set the necessary scopes for the API request
  SCOPES="https://www.googleapis.com/auth/youtube.force-ssl"

  # Set your API key file path and application name
  API_KEY_FILE="/Users/fkimmel/Dropbox/Tresor/key.json"
  APPLICATION_NAME="CLI"

  # Get the OAuth 2.0 access token
  ACCESS_TOKEN=$(google-oauthlib-tool --client-secrets $API_KEY_FILE \
                    --scope $SCOPES \
                    --save \
                    | grep access_token \
                    | cut -d' ' -f2)

  DESCRIPTION="LEP#125 - Wir zwei allein heut Nacht"
  PUBLISH_DATE="2021-11-12T09:00:00.000Z"

  echo $ACCESS_TOKEN

  # Construct the request body
  REQUEST_BODY=$(jq -n --arg desc "$DESCRIPTION" --arg date "$PUBLISH_DATE" '{snippet: {description: $desc, publishedAt: $date}}')

  # Make the API request to update the video
  curl --request PUT "https://www.googleapis.com/youtube/v3/videos?part=snippet&id=$VIDEO_ID" \
      --header "Authorization: Bearer $ACCESS_TOKEN" \
      --header "Content-Type: application/json" \
      --data "$REQUEST_BODY"

}

# :command.function
lep_ftp_command() {
  # src/ftp_command.sh
  file=${args[--file]}

  server_pwd=$(op item get "LEP_FTP" --format json | jq -r '. | .fields | .[] | select(.label=="password") | .value')
  server_username=$(op item get "LEP_FTP" --format json | jq -r '. | .fields | .[] | select(.label=="username") | .value')

  curl --user $server_username:$server_pwd --upload-file $file ftp://rssfeed.laufendentdecken-podcast.at

}

# :command.function
lep_automation_command() {
  # src/automation_command.sh
  skipFtp=${args[--skip-ftp]}
  skipAws=${args[--skip-aws]}
  skipAuphonic=${args[--skip-auphonic]}
  skipDownload=${args[--skip-download]}
  skipBlogpost=${args[--skip-blogpost]}

  ag1=${args[--ag1]}

  episode=${args[--m4a]}
  if [[ -z "$episode" ]]; then
      shopt -s nullglob # um die Schleife zu vermeiden, wenn keine m4a-Dateien vorhanden sind
      for file in ./*.m4a; do
          episode=$(basename "$file")
          break
      done
  fi

  echo "Start automatic workflow for file $episode"

  title=$(echo "$episode" | cut -d'.' -f 1)
  dataFile="$title".txt

  if [[ -e $dataFile ]]; then
      IFS=',' read -r postNumber postTitle postDate <<< "$(head -n 1 "$dataFile")"
  else
      while true; do
          read -p "Episode Nummer: " postNumber

          if [[ "$postNumber" =~ ^[0-9]*$ ]]; then
              break

          fi
      done
      read -p "Episode Titel: " postTitle

      while true; do
          read -p "Release (YYYY-MM-DD): " postDate

          if [[ "$postDate" =~ ^[0-9]{4}-[0-9]{2}-[0-9]{2}$ ]]; then
              break

          fi
      done

      echo "$postNumber,$postTitle,$postDate" >> $dataFile
  fi

  echo "Automate episode 'LEP#$postNumber - $postTitle' scheduled for $postDate"

  chapters=$(<"$title".chapters.txt)
  cover="$title".png

  if [[ -n "$ag1" ]]; then
      episodeAdFree="$title"_addfree.m4a
      titleAdFree="$title"_addfree
  else
      episodeAdFree=$episode
      titleAdFree=$title
  fi

  coverYoutube="$title"_youtube.png
  baseUrl="https://rssfeed.laufendentdecken-podcast.at/data/"

  coverUrl="$baseUrl$cover"
  coverUrlYoutube="$baseUrl$coverYoutube"

  if [[ -z "$skipFtp" ]]; then
      echo
      echo "Upload episode to FTP Server"
      lep ftp --file $episode

      if [[ -n "$ag1" ]]; then
          echo "Upload addfree episode to FTP Server"
          lep ftp --file $episodeAdFree
      fi

      echo "Upload cover to FTP Server"
      lep ftp --file $cover
      echo "Upload youtube cover to FTP Server"
      lep ftp --file $coverYoutube

  fi

  if [ $? -ne 0 ]; then
    exit 1
  fi

  if [[ -z "$skipAws" ]]; then
      echo
      echo "Backup to S3"

      aws s3 cp $episode s3://laufendentdecken-podcast/
      aws s3 cp s3://laufendentdecken-podcast/$episode s3://laufendentdecken-podcast-backup/

      if [[ -n "$ag1" ]]; then
          aws s3 cp $episodeAdFree s3://laufendentdecken-podcast/
          aws s3 cp s3://laufendentdecken-podcast/$episodeAdFree s3://laufendentdecken-podcast-backup/
      fi
  fi

  if [ $? -ne 0 ]; then
    exit 1
  fi

  if [[ -z "$skipAuphonic" ]]; then
      episodePreset="WbQunVJaZFitr3z74XTyxJ"
      youtubePreset="M9ageytQCjaFAYn7EjSYPZ"

      youtubeDescription=$(echo -e "HÃ¶rt rein auf:\nðŸ”—Https://laufendentdecken.at/$postNumber/\n\nUnd natÃ¼rlich auf\nðŸŽ§Spotify, iTunes, Google Podcast, zencastr und in allen podcatchern Ã¼ber das RSS Feed.\n\nâœ… Folge uns auf Instagram @laufendentdeckenpodcast , @floderandere und @redendentdecken\n\nUnd auf Facebook https://www.facebook.com/laufendentdeckenpodcast/\n\nWer uns unterstÃ¼tzen mag: https://www.patreon.com/laufendentdecken\noder Steady: https://steadyhq.com/de/laufendentdecken")

      lep auphonic  \
          --production_name $title \
          --preset $episodePreset\
          --cover_url $coverUrl \
          --file $episode \
          --slug $title

      lep auphonic  \
          --production_name "LEP#$postNumber - $postTitle" \
          --preset $youtubePreset \
          --cover_url $coverUrlYoutube \
          --file $episode \
          --slug $title \
          --description "$youtubeDescription"

      if [[ -n "$ag1" ]]; then
          lep auphonic  \
              --production_name "$title (addfree)" \
              --preset $episodePreset \
              --cover_url $coverUrl \
              --file $episodeAdFree \
              --slug $title
      fi

      echo "Podcast successfully uploaded"
  fi

  if [ $? -ne 0 ]; then
    exit 1
  fi

  if [[ -z "$skipDownload" ]]; then
      echo
      echo "Download adfree version again to be able to upload it to patroen/steady"
      curl https://rssfeed.laufendentdecken-podcast.at/data/$titleAdFree.mp3 --output ~/Downloads/$titleAdFree.mp3
  fi

  if [ $? -ne 0 ]; then
    exit 1
  fi

  if [[ -z "$skipBlogpost" ]]; then
      echo
      echo "Create Episode on Website"

      if [[ -z "$ag1" ]]; then
          lep blogpost \
              --number $postNumber \
              --title "$postTitle" \
              --publish_date $postDate \
              --slug $title
      fi

      if [[ -n "$ag1" ]]; then
          lep blogpost \
              --number $postNumber \
              --title "$postTitle" \
              --publish_date $postDate \
              --slug $title \
              --ag1
      fi

  fi

}

# :command.function
lep_auphonic_command() {
  # src/auphonic_command.sh
  title=${args[--slug]}
  episode=${args[--file]}
  coverUrl=${args[--cover_url]}
  auphonicTitle=${args[--production_name]}
  preset=${args[--preset]}
  noStart=${args[--no-start]}
  description=${args[--description]}

  chapters=$(<"$title".chapters.txt)

  auphonic_pwd=$(op item get "Auphonic" --format json | jq -r '. | .fields | .[] | select(.label=="password") | .value')
  auphonic_username=$( op item get "Auphonic" --format json | jq -r '. | .fields | .[] | select(.purpose=="USERNAME") | .value')

  action="start"

  # If no start is set, we just want to save the production
  if [[ -n "$noStart" ]]; then
      action="save"
  fi

  echo
  echo "Create $auphonicTitle Production"
  json=$(curl -s -X POST https://auphonic.com/api/simple/productions.json \
       -u $auphonic_username:$auphonic_pwd \
       -F "preset=$preset" \
       -F "service=Tz96q8s6vs7JetJeqD6PCC" \
       -F "title=$auphonicTitle" \
       -F "track=$title" \
       -F "chapters=$chapters" \
       -F "input_file=$episode" \
       -F "image=$coverUrl" \
       -F "summary=$description" \
       -F "action=$action")

  # Only query the status if we started the production
  if [[ -z "$noStart" ]]; then
      echo "Production started"
      content=$(echo $json | jq -r ' . | "\(.data.status_string):\(.data.uuid)"')
      IFS=':' read -ra response <<< "$content"

      status_string=${response[0]}
      uuid=${response[1]}

      echo "UUID: $uuid"
      echo -ne "Auphonic status: $status_string \r"

      while [[ $status_string != "Done"  ]]
      do
          json=$(curl -s -X GET https://auphonic.com/api/production/$uuid.json \
              -u $auphonic_username:$auphonic_pwd)

          status_string=$(echo $json | jq -r ' . | .data.status_string')

          echo -ne "Auphonic status: $status_string                         \r"
          sleep 2
      done
  else
      echo "Production $auphonicTitle saved"
  fi

}

# :command.function
lep_blogpost_command() {
  # src/blogpost_command.sh
  postNumber=${args[--number]}
  postTitle=${args[--title]}
  postDate=${args[--publish_date]}
  slug=${args[--slug]}

  ag1=${args[--ag1]}

  fullPostTitle="LEP#$postNumber - $postTitle"

  if [[ $postTitle == "Ein GesprÃ¤ch mit "* ]]; then
      guest=${postTitle#"Ein GesprÃ¤ch mit "}
      guest="Mehr Informationen zu $guest:Â Instagram | Facebook <br><br>"
  else
      guest=""
  fi

  content="<b>Werbefrei</b><br><br>ZusÃ¤tzlich habt ihr ab sofort die MÃ¶glichkeit euch das exklusive <a href='https://www.patreon.com/laufendentdecken'>Patreonfeed</a> zu sichern â€“ werbefrei und liebevoll exportiert.<br><br>Am besten direkt mitmachen und unterstÃ¼tzen: <a href='https://www.patreon.com/laufendentdecken'>Patreon</a><br><br><b>Links zum weiterlesen</b><br><br>$guest Wenn ihr den Podcast direkt ohne Installation hÃ¶ren mÃ¶chtet, kÃ¶nnt ihr das hier tun: Laufend Entdecken auf Podbay<br><br>Florian:Â <a href='http://twitter.com/laufenentdecken'>Twitter</a>,Â <a href='https://www.strava.com/athletes/1651823'>Strava</a><br>Peter:Â <a href='https://twitter.com/redendentdecken'>Twitter</a>,Â <a href='https://www.instagram.com/redendentdecken'>Instagram</a>,Â <a href='https://www.strava.com/athletes/24464941'>Strava</a><br><br><a href='http://facebook.com/laufendentdeckenblog/'>Facebook</a>,Â <a href='https://instagram.com/laufendentdeckenpodcast/'>Instagram</a>,Â <a href='https://www.strava.com/clubs/473847'>Strava Club</a>"

  if [[ -n "$ag1" ]]; then
      content="<b>Werbung</b><br><br>Informiere dich jetzt auf <a href='http://athleticgreens.com/laufendentdecken'>athleticgreens.com/laufendentdecken</a> , teste AG1 vÃ¶llig risikofrei mit 90 Tagen Geld-zurÃ¼ck-Garantie und sichere dir bei deiner AG1 Erstbestellung einen kostenlosen Jahresvorrat an Vitamin D3+K2 zur UnterstÃ¼tzung des Immunsystems & 5 praktische Travel Packs! Gesundheitsbezogene Angaben zu AG1 und unser Angebot findest du auf: <a href='http://athleticgreens.com/laufendentdecken'>athleticgreens.com/laufendentdecken</a><br><br>Auf die Bedeutung einer abwechslungsreichen und ausgewogenen ErnÃ¤hrung und einer gesunden Lebensweise wird hingewiesen. AuÃŸer Reichweite von Kindern aufbewahren. Nicht geeignet fÃ¼r Kinder und Jugendliche unter 18 Jahren, schwangere oder stillende Frauen. Die angegebene empfohlene tÃ¤gliche Verzehrmenge darf nicht Ã¼berschritten werden.<br><br>$content"
  fi

  apiKey=$(op item get "PodloveApiKey" --format json | jq -r '. | .fields | .[] | select(.label=="password") | .value')

  json=$(curl  -s -X POST https://laufendentdecken-podcast.at/wp-json/podlove/v2/episodes --header "Authorization: Basic $apiKey")

  episodeId=$(echo $json | jq -r ' . | "\(.id)"')
  response=$(curl -s -X POST https://laufendentdecken-podcast.at/wp-json/podlove/v2/episodes/$episodeId \
      --header "Authorization: Basic $apiKey" \
      --header 'Content-Type: application/json; charset=utf-8' \
      -d "{ \"slug\": \"$slug\", \"title\": \"$fullPostTitle\", \"number\": \"$postNumber\" }")

  json=$(curl -s -X GET https://laufendentdecken-podcast.at/wp-json/podlove/v2/episodes/$episodeId --header "Authorization: Basic $apiKey")
  postId=$(echo $json | jq -r ' . | "\(.post_id)"')

  response=$(curl -s -X POST https://laufendentdecken-podcast.at/wp-json/wp/v2/episodes/$postId \
      --header "Authorization: Basic $apiKey" \
      --header 'Content-Type: application/json; charset=utf-8' \
      --data-raw "{ \"title\":\"$fullPostTitle\", \"status\": \"future\", \"date\": \"$postDate 09:00:00\", \"slug\": \"$postNumber\", \"content\": \"<!-- wp:paragraph --> <!-- /wp:paragraph --> <!-- wp:paragraph -->$content<!-- /wp:paragraph -->\" }")

}

# :command.parse_requirements
parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --version | -v)
        version_command
        exit
        ;;

      --help | -h)
        long_usage=yes
        lep_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.dependencies_filter
  if command -v aws >/dev/null 2>&1; then
    deps['aws']="$(command -v aws | head -n1)"
  else
    printf "missing dependency: aws\n" >&2
    printf "%s\n" "install by running: 'brew install awscli'" >&2
    exit 1
  fi

  if command -v op >/dev/null 2>&1; then
    deps['op']="$(command -v op | head -n1)"
  else
    printf "missing dependency: op\n" >&2
    printf "%s\n" "install by running: 'brew install 1password-cli'" >&2
    exit 1
  fi

  if command -v jq >/dev/null 2>&1; then
    deps['jq']="$(command -v jq | head -n1)"
  else
    printf "missing dependency: jq\n" >&2
    printf "%s\n" "install by running: 'brew install jq'" >&2
    exit 1
  fi

  if command -v curl >/dev/null 2>&1; then
    deps['curl']="$(command -v curl | head -n1)"
  else
    printf "missing dependency: curl\n" >&2
    printf "%s\n" "Please install curl" >&2
    exit 1
  fi

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    youtube)
      action="youtube"
      shift
      lep_youtube_parse_requirements "$@"
      shift $#
      ;;

    ftp)
      action="ftp"
      shift
      lep_ftp_parse_requirements "$@"
      shift $#
      ;;

    automation)
      action="automation"
      shift
      lep_automation_parse_requirements "$@"
      shift $#
      ;;

    auphonic | a)
      action="auphonic"
      shift
      lep_auphonic_parse_requirements "$@"
      shift $#
      ;;

    blogpost | cb)
      action="blogpost"
      shift
      lep_blogpost_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      lep_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
lep_youtube_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        lep_youtube_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="youtube"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --title | -t)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--title']="$2"
          shift
          shift
        else
          printf "%s\n" "--title requires an argument: --title, -t TITLE" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --publish_date | -p)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--publish_date']="$2"
          shift
          shift
        else
          printf "%s\n" "--publish_date requires an argument: --publish_date, -p PUBLISH_DATE" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

  # :command.required_flags_filter
  if [[ -z ${args['--title']+x} ]]; then
    printf "missing required flag: --title, -t TITLE\n" >&2
    exit 1
  fi
  if [[ -z ${args['--publish_date']+x} ]]; then
    printf "missing required flag: --publish_date, -p PUBLISH_DATE\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
lep_ftp_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        lep_ftp_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="ftp"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --file | -f)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--file']="$2"
          shift
          shift
        else
          printf "%s\n" "--file requires an argument: --file, -f FILE" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

  # :command.required_flags_filter
  if [[ -z ${args['--file']+x} ]]; then
    printf "missing required flag: --file, -f FILE\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
lep_automation_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        lep_automation_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="automation"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --m4a | -m)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          # :flag.validations
          if [[ -n $(validate_file_exists "$2") ]]; then
            printf "validation error in %s:\n%s\n" "--m4a, -m M4A" "$(validate_file_exists "$2")" >&2
            exit 1
          fi

          args['--m4a']="$2"
          shift
          shift
        else
          printf "%s\n" "--m4a requires an argument: --m4a, -m M4A" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --ag1)

        # :flag.case_no_arg
        args['--ag1']=1
        shift
        ;;

      # :flag.case
      --skip-ftp)

        # :flag.case_no_arg
        args['--skip-ftp']=1
        shift
        ;;

      # :flag.case
      --skip-aws)

        # :flag.case_no_arg
        args['--skip-aws']=1
        shift
        ;;

      # :flag.case
      --skip-auphonic)

        # :flag.case_no_arg
        args['--skip-auphonic']=1
        shift
        ;;

      # :flag.case
      --skip-download)

        # :flag.case_no_arg
        args['--skip-download']=1
        shift
        ;;

      # :flag.case
      --skip-blogpost)

        # :flag.case_no_arg
        args['--skip-blogpost']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
lep_auphonic_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        lep_auphonic_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="auphonic"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --production_name | -n)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--production_name']="$2"
          shift
          shift
        else
          printf "%s\n" "--production_name requires an argument: --production_name, -n PRODUCTION_NAME" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --preset | -p)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--preset']="$2"
          shift
          shift
        else
          printf "%s\n" "--preset requires an argument: --preset, -p PRESET" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --cover_url | -c)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--cover_url']="$2"
          shift
          shift
        else
          printf "%s\n" "--cover_url requires an argument: --cover_url, -c COVER_URL" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --file | -f)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--file']="$2"
          shift
          shift
        else
          printf "%s\n" "--file requires an argument: --file, -f FILE" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --slug | -s)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--slug']="$2"
          shift
          shift
        else
          printf "%s\n" "--slug requires an argument: --slug, -s SLUG" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --description | -d)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--description']="$2"
          shift
          shift
        else
          printf "%s\n" "--description requires an argument: --description, -d DESCRIPTION" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --no-start)

        # :flag.case_no_arg
        args['--no-start']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

  # :command.required_flags_filter
  if [[ -z ${args['--production_name']+x} ]]; then
    printf "missing required flag: --production_name, -n PRODUCTION_NAME\n" >&2
    exit 1
  fi
  if [[ -z ${args['--preset']+x} ]]; then
    printf "missing required flag: --preset, -p PRESET\n" >&2
    exit 1
  fi
  if [[ -z ${args['--cover_url']+x} ]]; then
    printf "missing required flag: --cover_url, -c COVER_URL\n" >&2
    exit 1
  fi
  if [[ -z ${args['--file']+x} ]]; then
    printf "missing required flag: --file, -f FILE\n" >&2
    exit 1
  fi
  if [[ -z ${args['--slug']+x} ]]; then
    printf "missing required flag: --slug, -s SLUG\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
lep_blogpost_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        lep_blogpost_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="blogpost"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --ag1)

        # :flag.case_no_arg
        args['--ag1']=1
        shift
        ;;

      # :flag.case
      --number | -n)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--number']="$2"
          shift
          shift
        else
          printf "%s\n" "--number requires an argument: --number, -n NUMBER" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --title | -t)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--title']="$2"
          shift
          shift
        else
          printf "%s\n" "--title requires an argument: --title, -t TITLE" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --publish_date | -p)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--publish_date']="$2"
          shift
          shift
        else
          printf "%s\n" "--publish_date requires an argument: --publish_date, -p PUBLISH_DATE" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --slug | -s)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--slug']="$2"
          shift
          shift
        else
          printf "%s\n" "--slug requires an argument: --slug, -s SLUG" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

  # :command.required_flags_filter
  if [[ -z ${args['--number']+x} ]]; then
    printf "missing required flag: --number, -n NUMBER\n" >&2
    exit 1
  fi
  if [[ -z ${args['--title']+x} ]]; then
    printf "missing required flag: --title, -t TITLE\n" >&2
    exit 1
  fi
  if [[ -z ${args['--publish_date']+x} ]]; then
    printf "missing required flag: --publish_date, -p PUBLISH_DATE\n" >&2
    exit 1
  fi
  if [[ -z ${args['--slug']+x} ]]; then
    printf "missing required flag: --slug, -s SLUG\n" >&2
    exit 1
  fi

}

# :command.user_hooks
before_hook() {
  # src/before.sh
  op signin --account my.1password.com

}

# :command.initialize
initialize() {
  version="1.0.0"
  long_usage=''
  set -e

  # src/initialize.sh

}

# :command.run
run() {
  declare -A args=()
  declare -A deps=()
  declare -a other_args=()
  declare -a input=()
  normalize_input "$@"
  parse_requirements "${input[@]}"
  before_hook

  case "$action" in
    "youtube") lep_youtube_command ;;
    "ftp") lep_ftp_command ;;
    "automation") lep_automation_command ;;
    "auphonic") lep_auphonic_command ;;
    "blogpost") lep_blogpost_command ;;
  esac
}

initialize
run "$@"
