#!/usr/bin/env bash
# This script was generated by bashly 1.0.7 (https://bashly.dannyb.co)
# Modifying it manually is not recommended

# :wrapper.bash3_bouncer
if [[ "${BASH_VERSINFO:-0}" -lt 4 ]]; then
  printf "bash version 4 or higher is required\n" >&2
  exit 1
fi

# :command.master_script

# :command.version_command
version_command() {
  echo "$version"
}

# :command.usage
lep_usage() {
  if [[ -n $long_usage ]]; then
    printf "lep - Manage the laufendentdecken podcast via terminal\n"
    echo

  else
    printf "lep - Manage the laufendentdecken podcast via terminal\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  lep COMMAND\n"
  printf "  lep [COMMAND] --help | -h\n"
  printf "  lep --version | -v\n"
  echo
  # :command.usage_commands
  printf "%s\n" "Commands:"
  printf "  %s   Generate bash completions\n" "completions   "
  printf "  %s   Initialize episode\n" "init          "
  printf "  %s   Edit current episode description\n" "edit          "
  printf "  %s   Create a new iteration\n" "new           "
  printf "  %s   Check if ready to start automation\n" "check         "
  printf "  %s   Download file from ftp server\n" "download      "
  printf "  %s   Generate episode metadata\n" "metadata      "
  printf "  %s   Configure youtube video\n" "youtube       "
  printf "  %s   Upload file to self hosted ftp server\n" "ftp           "
  printf "  %s   Upload latest episode to youtube and start automatic post processing workflow\n" "upload-youtube"
  printf "  %s   Upload latest episode and start automatic post processing workflow\n" "automation    "
  printf "  %s   Start new auphonic production\n" "auphonic      "
  printf "  %s   Create wordpress blogpost on http://laufendentdecken-podcast.at\n" "blogpost      "
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo
    printf "  %s\n" "--version, -v"
    printf "    Show version number\n"
    echo

  fi
}

# :command.usage
lep_completions_usage() {
  if [[ -n $long_usage ]]; then
    printf "lep completions\n"
    echo

    printf "  Generate bash completions\n  Usage: eval \"\$(lep completions)\"\n"
    echo

  else
    printf "lep completions - Generate bash completions\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  lep completions\n"
  printf "  lep completions --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
lep_init_usage() {
  if [[ -n $long_usage ]]; then
    printf "lep init - Initialize episode\n"
    echo

  else
    printf "lep init - Initialize episode\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  lep init\n"
  printf "  lep init --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
lep_edit_usage() {
  if [[ -n $long_usage ]]; then
    printf "lep edit - Edit current episode description\n"
    echo

  else
    printf "lep edit - Edit current episode description\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  lep edit\n"
  printf "  lep edit --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
lep_new_usage() {
  if [[ -n $long_usage ]]; then
    printf "lep new - Create a new iteration\n"
    echo

  else
    printf "lep new - Create a new iteration\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  lep new\n"
  printf "  lep new --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
lep_check_usage() {
  if [[ -n $long_usage ]]; then
    printf "lep check - Check if ready to start automation\n"
    echo

  else
    printf "lep check - Check if ready to start automation\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  lep check [OPTIONS]\n"
  printf "  lep check --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--skip-youtube"
    printf "    Skip scheduling youtube video\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
lep_download_usage() {
  if [[ -n $long_usage ]]; then
    printf "lep download - Download file from ftp server\n"
    echo

  else
    printf "lep download - Download file from ftp server\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  lep download [OPTIONS]\n"
  printf "  lep download --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--file, -f FILE (required)"
    printf "    File to download\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
lep_metadata_usage() {
  if [[ -n $long_usage ]]; then
    printf "lep metadata - Generate episode metadata\n"
    echo

  else
    printf "lep metadata - Generate episode metadata\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  lep metadata [OPTIONS]\n"
  printf "  lep metadata --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--title, -t TITLE (required)"
    printf "    Episode Title\n"
    echo

    # :flag.usage
    printf "  %s\n" "--debug"
    printf "    Don't change any state in 1password\n"
    echo

    # :flag.usage
    printf "  %s\n" "--no-default-releasedate"
    printf "    Change default release date\n"
    echo

    # :flag.usage
    printf "  %s\n" "--no-default-postnumber"
    printf "    Change default post number\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
lep_youtube_usage() {
  if [[ -n $long_usage ]]; then
    printf "lep youtube - Configure youtube video\n"
    echo

  else
    printf "lep youtube - Configure youtube video\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  lep youtube [OPTIONS]\n"
  printf "  lep youtube --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--title, -t TITLE (required)"
    printf "    Episode Title\n"
    echo

    # :flag.usage
    printf "  %s\n" "--publish_date, -p PUBLISH_DATE (required)"
    printf "    Publish Date\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
lep_ftp_usage() {
  if [[ -n $long_usage ]]; then
    printf "lep ftp - Upload file to self hosted ftp server\n"
    echo

  else
    printf "lep ftp - Upload file to self hosted ftp server\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  lep ftp [OPTIONS]\n"
  printf "  lep ftp --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--file, -f FILE (required)"
    printf "    File to upload\n"
    echo

    # :flag.usage
    printf "  %s\n" "--name, -n NAME (required)"
    printf "    Name of file on server\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
lep_upload_youtube_usage() {
  if [[ -n $long_usage ]]; then
    printf "lep upload-youtube - Upload latest episode to youtube and start automatic post processing workflow\n"
    echo

  else
    printf "lep upload-youtube - Upload latest episode to youtube and start automatic post processing workflow\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  lep upload-youtube\n"
  printf "  lep upload-youtube --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
lep_automation_usage() {
  if [[ -n $long_usage ]]; then
    printf "lep automation - Upload latest episode and start automatic post processing workflow\n"
    echo

  else
    printf "lep automation - Upload latest episode and start automatic post processing workflow\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  lep automation [OPTIONS]\n"
  printf "  lep automation --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--m4a, -m M4A"
    printf "    Episode as m4a\n"
    echo

    # :flag.usage
    printf "  %s\n" "--time TIME"
    printf "    Start time of the episode\n"
    printf "    Default: 09:00:00\n"
    echo

    # :flag.usage
    printf "  %s\n" "--force"
    printf "    No sanity check before automation starts\n"
    echo

    # :flag.usage
    printf "  %s\n" "--ag1"
    printf "    This episodes is supportd by AG1\n"
    echo

    # :flag.usage
    printf "  %s\n" "--polestar"
    printf "    This episodes is supportd by Polestar\n"
    echo

    # :flag.usage
    printf "  %s\n" "--debug"
    printf "    Dont change\n"
    echo

    # :flag.usage
    printf "  %s\n" "--no-default-releasedate"
    printf "    Change default release date\n"
    echo

    # :flag.usage
    printf "  %s\n" "--skip-ftp"
    printf "    Skip upload to FTP server\n"
    echo

    # :flag.usage
    printf "  %s\n" "--skip-aws"
    printf "    Skip upload to aws\n"
    echo

    # :flag.usage
    printf "  %s\n" "--skip-auphonic"
    printf "    Skip upload to Auphonic\n"
    echo

    # :flag.usage
    printf "  %s\n" "--skip-download"
    printf "    Skip download from patreon\n"
    echo

    # :flag.usage
    printf "  %s\n" "--skip-blogpost"
    printf "    Skip create blogpost\n"
    echo

    # :flag.usage
    printf "  %s\n" "--skip-youtube"
    printf "    Skip scheduling youtube video\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  lep upload --m4a episode.m4a\n"
    echo

  fi
}

# :command.usage
lep_auphonic_usage() {
  if [[ -n $long_usage ]]; then
    printf "lep auphonic - Start new auphonic production\n"
    echo

  else
    printf "lep auphonic - Start new auphonic production\n"
    echo

  fi

  printf "Alias: a\n"
  echo

  printf "%s\n" "Usage:"
  printf "  lep auphonic [OPTIONS]\n"
  printf "  lep auphonic --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--production_name, -n PRODUCTION_NAME (required)"
    printf "    Auphonic production name\n"
    echo

    # :flag.usage
    printf "  %s\n" "--preset, -p PRESET (required)"
    printf "    Auphonic preset\n"
    echo

    # :flag.usage
    printf "  %s\n" "--cover_url, -c COVER_URL (required)"
    printf "    URL of the cover image\n"
    echo

    # :flag.usage
    printf "  %s\n" "--file, -f FILE (required)"
    printf "    File name of the production\n"
    echo

    # :flag.usage
    printf "  %s\n" "--slug, -s SLUG (required)"
    printf "    Slug of the auphonic production\n"
    echo

    # :flag.usage
    printf "  %s\n" "--description, -d DESCRIPTION"
    printf "    Description of the episode\n"
    echo

    # :flag.usage
    printf "  %s\n" "--no-start"
    printf "    Dont automatically start the auphonic production\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  lep auphonic --production_name episode1 --preset \"123823\" --cover_url\n  \"http://url\" --file episode1.m4a --slug episode1\n"
    echo

  fi
}

# :command.usage
lep_blogpost_usage() {
  if [[ -n $long_usage ]]; then
    printf "lep blogpost - Create wordpress blogpost on http://laufendentdecken-podcast.at\n"
    echo

  else
    printf "lep blogpost - Create wordpress blogpost on http://laufendentdecken-podcast.at\n"
    echo

  fi

  printf "Alias: cb\n"
  echo

  printf "%s\n" "Usage:"
  printf "  lep blogpost [OPTIONS]\n"
  printf "  lep blogpost --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--ag1"
    printf "    This episodes is supportd by AG1\n"
    echo

    # :flag.usage
    printf "  %s\n" "--polestar"
    printf "    This episodes is supportd by Polestar\n"
    echo

    # :flag.usage
    printf "  %s\n" "--number, -n NUMBER (required)"
    printf "    Episode Number\n"
    echo

    # :flag.usage
    printf "  %s\n" "--title, -t TITLE (required)"
    printf "    Episode Title\n"
    echo

    # :flag.usage
    printf "  %s\n" "--publish_date, -p PUBLISH_DATE (required)"
    printf "    Publish Date\n"
    echo

    # :flag.usage
    printf "  %s\n" "--slug, -s SLUG (required)"
    printf "    Slug of the auphonic production\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  lep create-blogpost --number 1 --title \"Episode Title\" --publish_date\n  \"2049-12-31\" --slug \"slug\"\n"
    echo

  fi
}

# :command.normalize_input
normalize_input() {
  local arg flags

  while [[ $# -gt 0 ]]; do
    arg="$1"
    if [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then
      flags="${BASH_REMATCH[1]}"
      for ((i = 0; i < ${#flags}; i++)); do
        input+=("-${flags:i:1}")
      done
    else
      input+=("$arg")
    fi

    shift
  done
}
# :command.inspect_args
inspect_args() {
  if ((${#args[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!args[@]}" | sort)
    echo args:
    for k in "${sorted_keys[@]}"; do echo "- \${args[$k]} = ${args[$k]}"; done
  else
    echo args: none
  fi

  if ((${#other_args[@]})); then
    echo
    echo other_args:
    echo "- \${other_args[*]} = ${other_args[*]}"
    for i in "${!other_args[@]}"; do
      echo "- \${other_args[$i]} = ${other_args[$i]}"
    done
  fi

  if ((${#deps[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!deps[@]}" | sort)
    echo
    echo deps:
    for k in "${sorted_keys[@]}"; do echo "- \${deps[$k]} = ${deps[$k]}"; done
  fi

}

# :command.user_lib
# src/lib/send_completions.sh
send_completions() {
  echo $'# lep completion                                           -*- shell-script -*-'
  echo $''
  echo $'# This bash completions script was generated by'
  echo $'# completely (https://github.com/dannyben/completely)'
  echo $'# Modifying it manually is not recommended'
  echo $''
  echo $'_lep_completions_filter() {'
  echo $'  local words="$1"'
  echo $'  local cur=${COMP_WORDS[COMP_CWORD]}'
  echo $'  local result=()'
  echo $''
  echo $'  if [[ "${cur:0:1}" == "-" ]]; then'
  echo $'    echo "$words"'
  echo $'  '
  echo $'  else'
  echo $'    for word in $words; do'
  echo $'      [[ "${word:0:1}" != "-" ]] && result+=("$word")'
  echo $'    done'
  echo $''
  echo $'    echo "${result[*]}"'
  echo $''
  echo $'  fi'
  echo $'}'
  echo $''
  echo $'_lep_completions() {'
  echo $'  local cur=${COMP_WORDS[COMP_CWORD]}'
  echo $'  local compwords=("${COMP_WORDS[@]:1:$COMP_CWORD-1}")'
  echo $'  local compline="${compwords[*]}"'
  echo $''
  echo $'  case "$compline" in'
  echo $'    \'completions\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_lep_completions_filter "--help -h")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'automation\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_lep_completions_filter "--ag1 --debug --force --help --m4a --no-default-releasedate --polestar --skip-auphonic --skip-aws --skip-blogpost --skip-download --skip-ftp --skip-youtube --time -h -m")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'auphonic\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_lep_completions_filter "--cover_url --description --file --help --no-start --preset --production_name --slug -c -d -f -h -n -p -s")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'download\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_lep_completions_filter "--file --help -f -h")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'metadata\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_lep_completions_filter "--debug --help --no-default-postnumber --no-default-releasedate --title -h -t")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'blogpost\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_lep_completions_filter "--ag1 --help --number --polestar --publish_date --slug --title -h -n -p -s -t")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'youtube\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_lep_completions_filter "--help --publish_date --title -h -p -t")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'check\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_lep_completions_filter "--help --skip-youtube -h")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'init\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_lep_completions_filter "--help -h")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'ftp\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_lep_completions_filter "--file --help --name -f -h -n")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'cb\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_lep_completions_filter "--ag1 --help --number --polestar --publish_date --slug --title -h -n -p -s -t")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'a\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_lep_completions_filter "--cover_url --description --file --help --no-start --preset --production_name --slug -c -d -f -h -n -p -s")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    *)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_lep_completions_filter "--help --version -h -v a auphonic automation blogpost cb check completions download ftp init metadata youtube")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'  esac'
  echo $'} &&'
  echo $'complete -F _lep_completions lep'
  echo $''
  echo $'# ex: filetype=sh'
}

# src/lib/validations/validate_dir_exists.sh
validate_dir_exists() {
  [[ -d "$1" ]] || echo "must be an existing directory"
}

# src/lib/validations/validate_file_exists.sh
validate_file_exists() {
  [[ -f "$1" ]] || echo "must be an existing file"
}

# src/lib/validations/validate_integer.sh
validate_integer() {
  [[ "$1" =~ ^[0-9]+$ ]] || echo "must be an integer"
}

# src/lib/validations/validate_not_empty.sh
validate_not_empty() {
  [[ -z "$1" ]] && echo "must not be empty"
}

# :command.command_functions
# :command.function
lep_completions_command() {
  # src/completions_command.sh
  # Call the `send_completions` function which was added by running:
  #
  #   $ bashly add completions
  #
  # Users can now enable bash completion for this script by running:
  #
  #   $ eval "$(lep completions)"
  #
  send_completions

}

# :command.function
lep_init_command() {
  # src/init_command.sh
  folder=$(basename "$(pwd)")
  touch "$folder.md"
  window=$(tmux display-message -p '#I')
  tmux rename-window -t Aufnahmen:$window $folder
  fish -c "vim $folder.md"

}

# :command.function
lep_edit_command() {
  # src/edit_command.sh
  folder=$(basename "$(pwd)")
  nvim "$folder.md"

}

# :command.function
lep_new_command() {
  # src/new_command.sh
  #!/bin/bash

  baseName=$(basename "$(pwd)")
  newBaseName=$(basename "$(pwd)")
  episode="$baseName.m4a"
  counter=1
  latestCounter=1

  while [ -e "$episode" ]; do
      episode="$baseName-$counter.m4a"
      latestCounter=$counter
      ((counter++))
  done

  cp "$baseName.md" "$baseName-$latestCounter.md"
  cp "$baseName.txt" "$latestCounter.txt"
  cp "$baseName.png" "$latestCounter.png"

}

# :command.function
lep_check_command() {
  # src/check_command.sh
  skipYoutube=${args[--skip-youtube]}

  folder=$(basename "$(pwd)")
  episode=$folder
  error=0
  counter=1

  while [ -e "$folder-$counter.m4a" ]; do
      episode="$folder-$counter"
      ((counter++))
  done

  echo "Checking for $episode.m4a"

  if [[ $episode =~ [öüäÖÜÄ] ]]; then
    echo -e "\e[31m Episode title contains Umlaute \e[0m"
    error=1
  else
    echo -e "\e[32m Episode title does not have Umlaute\e[0m"
  fi

  if [[ -e "$episode.m4a" ]]; then
      echo -e "\e[32m Episode is already exported\e[0m"
  else

      echo -e "\e[31m No Episode is exported to automate\e[0m"
      error=1
  fi

  if [[ -e "${episode}_adfree.m4a" ]]; then
      echo -e "\e[32m Adfree Episode is already exported\e[0m"
  else
      echo -e "\e[33m No Adfree Episode \e[0m"
  fi

  if [[ -e "$episode.md" ]]; then
      echo -e "\e[32m Episode description exists\e[0m"
  else

      echo -e "\e[31m No Episode description available\e[0m"
      error=1
  fi

  if [[ -s "$episode.md" ]]; then
      echo -e "\e[32m Episode description is not empty\e[0m"
  else

      echo -e "\e[31m Episode description is empty\e[0m"
      error=1
  fi

  if [[ -e "$episode.png" ]]; then
      echo -e "\e[32m Episode thumbnail exists\e[0m"
  else

      echo -e "\e[31m No Episode thumbnail available\e[0m"
      error=1
  fi

  if [[ -z "$skipYoutube" ]]; then
      if [[ -e "${episode}_youtube.png" ]]; then
          echo -e "\e[32m Episode youtube thumbnail exists\e[0m"
      else

          echo -e "\e[31m No Episode youtube thumbnail available\e[0m"
          error=1
      fi
  fi

  if [[ -e "$episode.chapters.txt" ]]; then
      echo -e "\e[32m Episode chapters exists\e[0m"
  else

      echo -e "\e[31m No Episode chapters available\e[0m"
      error=1
  fi

  exit $error

}

# :command.function
lep_download_command() {
  # src/download_command.sh
  file=${args[--file]}
  folder=$(echo $file | awk -F '_' '{print $2}' | cut -d '.' -f 1)

  curl https://rssfeed.laufendentdecken-podcast.at/data/$file --output ~/Dropbox/Resources/Podcast/Aufnahmen/$folder/$file

}

# :command.function
lep_metadata_command() {
  # src/metadata_command.sh
  title=${args[--title]}
  debug=${args[--debug]}
  noDefaultReleaseDate=${args[--no-default-releasedate]}
  noDefaultPostNumber=${args[--no-default-postnumber]}

  dataFile="$title.txt"
  contentFile="$title.html"
  sourceFile="$title.md"

  if ! [[ -e $contentFile ]]; then
      echo " Generating html content file"
      pandoc -s -o $contentFile $sourceFile > /dev/null
  fi

  if ! [[ -e $dataFile ]]; then

      if [[ -n "$noDefaultPostNumber" ]] then
          read -p "Release number: " postNumber
      else
          postNumber=$(op read "op://Podcast/Podcast/Episode")
          postNumber=$(expr $postNumber + 1)

          if [[ -z "$debug" ]]; then
              op item edit --vault Podcast 'Podcast' 'Episode='$postNumber > /dev/null
          fi

      fi

      echo
      option=$(gum choose --header "Title Template" "Gespräch" "Wiedersehen" "Custom")

      case $option in
          "Gespräch")
              postTitle="Ein Gespräch mit "
              ;;
          "Wiedersehen")
              postTitle="Ein Wiedersehen mit "
              ;;
          "Custom")
              postTitle=""
              ;;
      esac

      if [[ -n "$postTitle" ]]; then
          name=$(echo $title | sed 's/\([a-z]\)\([A-Z]\)/\1 \2/g')
          postTitle=$postTitle$name
      else
          read -p "Custom title: " postTitle
      fi

      if [[ -n "$noDefaultReleaseDate" ]] then
          while true; do
              read -p "Release Date:  " postDate

              if [[ "$postDate" =~ ^[0-9]{4}-[0-9]{2}-[0-9]{2}$ ]]; then
                  break

              fi
          done
      else

          postDate=$(date -v+friday '+%Y-%m-%d')

      fi

      echo "$postNumber,$postTitle,$postDate" >> $dataFile
  fi

  IFS=',' read -r postNumber postTitle postDate <<< "$(head -n 1 "$title"".txt")"

}

# :command.function
lep_youtube_command() {
  # src/youtube_command.sh
  #!/bin/bash

  PUBLISH_DATE=$(date -jf "%Y-%m-%d %H:%M:%S" "${args[--publish_date]}" "+%Y-%m-%dT%H:%M:%S%z")
  DESCRIPTION=${args[--title]}

  API_KEY=$(op read "op://Podcast/Youtube/credential")

  local length="${#DESCRIPTION}"
  local result=''

  for ((i = 0; i < length; i++)); do
      local char="${DESCRIPTION:i:1}"
      case $char in
          [a-zA-Z0-9.~_-])
              result+="$char"
              ;;
          *)
              printf -v hex '%%%02X' "'$char"
              result+="$hex"
              ;;
      esac
  done

  # Set the necessary scopes for the API request
  SCOPES="https://www.googleapis.com/auth/youtube.force-ssl"

  client_id=$(op read "op://Podcast/Youtube/client_id")
  client_secret=$(op read "op://Podcast/Youtube/client_secret")
  refresh_token=$(op read "op://Podcast/Youtube/refresh_token")

  # Get the access token
  ACCESS_TOKEN=$(curl -s -X POST "https://oauth2.googleapis.com/token" \
                      -H "Content-Type: application/x-www-form-urlencoded" \
                      -d "client_id=$client_id&client_secret=$client_secret&refresh_token=$refresh_token&grant_type=refresh_token" \
                      | jq -r '.access_token')

  # Send a request to the YouTube Data API to search for the video
  JSON=$(curl -s "https://www.googleapis.com/youtube/v3/search?key=$API_KEY&q=$result&part=id&part=snippet&maxResults=1&type=video&forMine=true" \
      --header "Authorization: Bearer $ACCESS_TOKEN" \
      --header 'Accept: application/json' \
  )

  # Parse the JSON response to extract the video ID
  VIDEO_ID=$(echo "$JSON" | jq -r '.items[0].id.videoId')

  REQUEST_BODY=$(jq -n --arg videoId "$VIDEO_ID" --arg date $PUBLISH_DATE '{ id: $videoId, status: { privacyStatus: "private", "publishAt": $date , "license": "youtube", "publicStatsViewable": true } }')

  # Make the API request to update the video
  SCHEDULE_RESPONSE=$(curl -s -X PUT "https://youtube.googleapis.com/youtube/v3/videos?part=status" \
      --header "Authorization: Bearer $ACCESS_TOKEN" \
      --header 'Accept: application/json' \
      --header 'Content-Type: application/json' \
      --data "$REQUEST_BODY")

  echo " Youtube Video has been scheduled"

}

# :command.function
lep_ftp_command() {
  # src/ftp_command.sh
  file=${args[--file]}
  name=${args[--name]}

  server_pwd=$(op read "op://Podcast/ahvoh5qmumxyrtvih2klge7uqa/credential")
  server_username=$(op read "op://Podcast/ahvoh5qmumxyrtvih2klge7uqa/username")

  curl --user $server_username:$server_pwd --upload-file $file ftp://rssfeed.laufendentdecken-podcast.at/$name

}

# :command.function
lep_upload_youtube_command() {
  # src/upload_youtube_command.sh
  defaultAirTime="09:00:00"
  episode=$(basename "$(pwd)")
  episode="$episode.m4a"

  baseUrl="https://rssfeed.laufendentdecken-podcast.at/data/"
  title=$(echo "$episode" | cut -d'.' -f 1)

  IFS=',' read -r postNumber postTitle postDate <<< "$(head -n 1 "$title"".txt")"

  coverYoutube="$title"_youtube.png
  coverYoutubeWithPostNumber="$postNumber"_"$coverYoutube"
  coverUrlYoutube="$baseUrl$coverYoutubeWithPostNumber"

  slug="$postNumber"_"$title"
  youtubePreset=$(op read "op://Podcast/Auphonic Api/youtubePreset")

  youtubeDescription=$(echo -e "\n\nHört rein auf:\n🔗Https://laufendentdecken.at/$postNumber/\n\nUnd natürlich auf\n🎧Spotify, iTunes, Google Podcast, zencastr und in allen podcatchern über das RSS Feed.\n\n✅ Folge uns auf Instagram @laufendentdeckenpodcast , @floderandere und @redendentdecken\n\nUnd auf Facebook https://www.facebook.com/laufendentdeckenpodcast/\n\nWer uns unterstützen mag: https://www.patreon.com/laufendentdecken\noder Steady: https://steadyhq.com/de/laufendentdecken")
  episodeWithPostNumber="$postNumber"_"$episode"

  echo "██╗     ███████╗██████╗      ██████╗██╗     ██╗";
  echo "██║     ██╔════╝██╔══██╗    ██╔════╝██║     ██║";
  echo "██║     █████╗  ██████╔╝    ██║     ██║     ██║";
  echo "██║     ██╔══╝  ██╔═══╝     ██║     ██║     ██║";
  echo "███████╗███████╗██║         ╚██████╗███████╗██║";
  echo "╚══════╝╚══════╝╚═╝          ╚═════╝╚══════╝╚═╝";
  echo "                                               ";

  lep check

  if [ $? -ne 0 ]; then
    exit 1
  fi

  echo "  Upload youtube cover to FTP Server"
  lep ftp --file $coverYoutube --name $coverYoutubeWithPostNumber

  if [ $? -ne 0 ]; then
    exit 1
  fi

  echo " Automate episode 'LEP#$postNumber - $postTitle' scheduled for $postDate"

  lep auphonic  \
      --production_name "LEP#$postNumber - $postTitle" \
      --preset $youtubePreset \
      --cover_url $coverUrlYoutube \
      --file $episodeWithPostNumber \
      --slug $slug \
      --description "$youtubeDescription"

  if [ $? -ne 0 ]; then
    exit 1
  fi

  echo
  echo " Schedule youtube video"
  lep youtube \
      --title "LEP#$postNumber" \
      --publish_date "$postDate $defaultAirTime"

}

# :command.function
lep_automation_command() {
  # src/automation_command.sh
  skipFtp=${args[--skip-ftp]}
  skipAws=${args[--skip-aws]}
  skipAuphonic=${args[--skip-auphonic]}
  skipDownload=${args[--skip-download]}
  skipBlogpost=${args[--skip-blogpost]}
  skipYoutube=${args[--skip-youtube]}
  #skipYoutube="skip-per-default"
  force=${args[--force]}
  noDefaultReleaseDate=${args[--no-default-releasedate]}
  noDefaultPostNumber=${args[--no-default-postnumber]}

  defaultAirTime=${args[--time]}

  ag1=${args[--ag1]}
  polestar=${args[--polestar]}
  debug=${args[--debug]}

  episode=${args[--m4a]}
  if [[ -z "$episode" ]]; then
      episode=$(basename "$(pwd)")
      episode="$episode.m4a"
  fi

  echo "██╗     ███████╗██████╗      ██████╗██╗     ██╗";
  echo "██║     ██╔════╝██╔══██╗    ██╔════╝██║     ██║";
  echo "██║     █████╗  ██████╔╝    ██║     ██║     ██║";
  echo "██║     ██╔══╝  ██╔═══╝     ██║     ██║     ██║";
  echo "███████╗███████╗██║         ╚██████╗███████╗██║";
  echo "╚══════╝╚══════╝╚═╝          ╚═════╝╚══════╝╚═╝";
  echo "                                               ";

  if [[ -z "$force" ]]; then
      if [[ -z "$skipYoutube" ]]; then
          lep check
      else

          lep check --skip-youtube
      fi
  fi

  if [ $? -ne 0 ]; then
    exit 1
  fi

  echo "󰀂Start automatic workflow for file $episode"

  title=$(echo "$episode" | cut -d'.' -f 1)
  ad=$(([ -n "$ag1" ] || [ -n "$polestar" ]) && echo "true" || echo "false")

  if [[ -e "$title"_adfree.m4a ]] && [[ "$ad" = "false" ]]; then
      option=$(gum choose --header "Adfree version detected, but no advertisement provided" "AG1" "Polestar")
      case $option in
          "AG1")
              ag1="1"
              ;;
          "Polestar")
              polestar="1"
              ;;
      esac
      ad="true"
  fi

  if [[ -n "$debug" ]]; then
      if [[ -n "$noDefaultReleaseDate" ]]; then
          if [[ -n "$noDefaultPostNumber" ]]; then
              lep metadata --title $title --debug --no-default-releasedate --no-default-postnumber

          else

              lep metadata --title $title --debug --no-default-releasedate

          fi
      else

          if [[ -n "$noDefaultPostNumber" ]]; then
              lep metadata --title $title --debug --no-default-postnumber

          else

              lep metadata --title $title --debug

          fi
      fi
  else

      if [[ -n "$noDefaultReleaseDate" ]]; then
          if [[ -n "$noDefaultPostNumber" ]]; then
              lep metadata --title $title --no-default-releasedate --no-default-postnumber

          else

              lep metadata --title $title --no-default-releasedate

          fi
      else

          if [[ -n "$noDefaultPostNumber" ]]; then
              lep metadata --title $title --no-default-postnumber

          else

              lep metadata --title $title

          fi
      fi
  fi

  IFS=',' read -r postNumber postTitle postDate <<< "$(head -n 1 "$title"".txt")"

  echo " Automate episode 'LEP#$postNumber - $postTitle' scheduled for $postDate"

  chapters=$(<"$title".chapters.txt)
  cover="$title".png

  if [[ "$ad" = "true" ]]; then
      episodeAdFree="$title"_adfree.m4a
      titleAdFree="$title"_adfree
  else
      episodeAdFree=$episode
      titleAdFree=$title
  fi

  coverYoutube="$title"_youtube.png
  baseUrl="https://rssfeed.laufendentdecken-podcast.at/data/"

  coverWithPostNumber="$postNumber"_"$cover"
  coverYoutubeWithPostNumber="$postNumber"_"$coverYoutube"

  coverUrl="$baseUrl$coverWithPostNumber"
  coverUrlYoutube="$baseUrl$coverYoutubeWithPostNumber"

  episodeWithPostNumber="$postNumber"_"$episode"
  episodeAdFreeWithPostNumber="$postNumber"_"$episodeAdFree"
  slug="$postNumber"_"$title"
  slugAdFree="$postNumber"_"$titleAdFree"

  if [[ -z "$skipFtp" ]]; then
      echo
      echo "  Upload episode to FTP Server"
      lep ftp --file $episode --name $episodeWithPostNumber

      if [[ "$ad" = "true" ]]; then
          echo "  Upload adfree episode to FTP Server"
          lep ftp --file $episodeAdFree --name $episodeAdFreeWithPostNumber
      fi

      echo "  Upload cover to FTP Server"
      lep ftp --file $cover --name $coverWithPostNumber

      if [[ -z "$skipYoutube" ]]; then
          echo "  Upload youtube cover to FTP Server"
          lep ftp --file $coverYoutube --name $coverYoutubeWithPostNumber

      fi
  fi

  if [ $? -ne 0 ]; then
    exit 1
  fi

  if [[ -z "$skipAws" ]]; then
      echo
      echo " Backup to S3"

      aws s3 cp $episode s3://laufendentdecken-podcast/$episodeWithPostNumber
      aws s3 cp s3://laufendentdecken-podcast/$episodeWithPostNumber s3://laufendentdecken-podcast-backup/

      if [[ "$ad" = "true" ]]; then
          aws s3 cp $episodeAdFree s3://laufendentdecken-podcast/$episodeAdFreeWithPostNumber
          aws s3 cp s3://laufendentdecken-podcast/$episodeAdFreeWithPostNumber s3://laufendentdecken-podcast-backup/
      fi
  fi

  if [ $? -ne 0 ]; then
    exit 1
  fi

  if [[ -z "$skipAuphonic" ]]; then
      episodePreset=$(op read "op://Podcast/Auphonic Api/episodePreset")

      youtubePreset=$(op read "op://Podcast/Auphonic Api/youtubePreset")

      description=$(pbpaste | tr '\n' ' ')
      youtubeDescription=$(echo -e "${description}\n\nHört rein auf:\n🔗Https://laufendentdecken.at/$postNumber/\n\nUnd natürlich auf\n🎧Spotify, iTunes, Google Podcast, zencastr und in allen podcatchern über das RSS Feed.\n\n✅ Folge uns auf Instagram @laufendentdeckenpodcast , @floderandere und @redendentdecken\n\nUnd auf Facebook https://www.facebook.com/laufendentdeckenpodcast/\n\nWer uns unterstützen mag: https://www.patreon.com/laufendentdecken\noder Steady: https://steadyhq.com/de/laufendentdecken")

      lep auphonic  \
          --production_name $title \
          --preset $episodePreset\
          --cover_url $coverUrl \
          --file $episodeWithPostNumber \
          --slug $slug

      if [[ -z "$skipYoutube" ]]; then
          lep auphonic  \
              --production_name "LEP#$postNumber - $postTitle" \
              --preset $youtubePreset \
              --cover_url $coverUrlYoutube \
              --file $episodeWithPostNumber \
              --slug $slug \
              --description "$youtubeDescription"
      fi

      if [[ "$ad" = "true" ]]; then
          lep auphonic  \
              --production_name "$title (adfree)" \
              --preset $episodePreset \
              --cover_url $coverUrl \
              --file $episodeAdFreeWithPostNumber \
              --slug $slug
      fi

      echo " Podcast successfully uploaded"
  fi

  if [ $? -ne 0 ]; then
    exit 1
  fi

  if [[ -z "$skipDownload" ]]; then
      echo
      echo " Download adfree version again to be able to upload it to patroen/steady"
      lep download --file "$slugAdFree.mp3"

  fi

  if [ $? -ne 0 ]; then
    exit 1
  fi

  if [[ -z "$skipBlogpost" ]]; then
      echo
      echo "󰜏Create Episode on Website"

      if [[ "$ad" = "false" ]]; then
          lep blogpost \
              --number $postNumber \
              --title "$postTitle" \
              --publish_date "$postDate $defaultAirTime" \
              --slug $slug
      fi

      if [[ -n "$ag1" ]]; then
          lep blogpost \
              --number $postNumber \
              --title "$postTitle" \
              --publish_date "$postDate $defaultAirTime" \
              --slug $slug \
              --ag1
      fi

      if [[ -n "$polestar" ]]; then
          lep blogpost \
              --number $postNumber \
              --title "$postTitle" \
              --publish_date "$postDate $defaultAirTime" \
              --slug $slug \
              --polestar
      fi

  fi

  if [[ -z "$skipYoutube" ]]; then
      echo
      echo " Schedule youtube video"
      lep youtube \
          --title "LEP#$postNumber" \
          --publish_date "$postDate $defaultAirTime"
  fi

}

# :command.function
lep_auphonic_command() {
  # src/auphonic_command.sh
  title=${args[--slug]}
  episode=${args[--file]}
  coverUrl=${args[--cover_url]}
  auphonicTitle=${args[--production_name]}
  preset=${args[--preset]}
  noStart=${args[--no-start]}
  description=${args[--description]}

  name=$(echo "${title#*_}")
  chapters=$(<"$name".chapters.txt)

  auphonic_pwd=$(op read "op://Podcast/Auphonic Api/credential")

  auphonic_username=$(op read "op://Podcast/Auphonic Api/username")

  action="start"

  if [[ -n "$noStart" ]]; then
      action="save"
  fi

  echo
  echo " Create $auphonicTitle Production"
  json=$(curl -s -X POST https://auphonic.com/api/simple/productions.json \
       -u $auphonic_username:$auphonic_pwd \
       -F "preset=$preset" \
       -F "service=Tz96q8s6vs7JetJeqD6PCC" \
       -F "title=$auphonicTitle" \
       -F "track=$title" \
       -F "chapters=$chapters" \
       -F "input_file=$episode" \
       -F "image=$coverUrl" \
       -F "summary=$description" \
       -F "action=$action")

  if [[ -z "$noStart" ]]; then
      echo " Production started"
      content=$(echo $json | jq -r ' . | "\(.data.status_string):\(.data.uuid)"')
      IFS=':' read -ra response <<< "$content"

      status_string=${response[0]}
      uuid=${response[1]}

      echo "UUID: $uuid"
      echo -ne "Auphonic status: $status_string \r"

      while [[ $status_string != "Done"  ]]
      do
          json=$(curl -s -X GET https://auphonic.com/api/production/$uuid.json \
              -u $auphonic_username:$auphonic_pwd)

          status_string=$(echo $json | jq -r ' . | .data.status_string')

          echo -ne "Auphonic status: $status_string                         \r"
          sleep 2
      done
  else
      echo " Production $auphonicTitle saved"
  fi

}

# :command.function
lep_blogpost_command() {
  # src/blogpost_command.sh
  postNumber=${args[--number]}
  postTitle=${args[--title]}
  postDate=${args[--publish_date]}
  slug=${args[--slug]}

  ag1=${args[--ag1]}
  polestar=${args[--polestar]}

  fullPostTitle="LEP#$postNumber - $postTitle"

  title=$(echo "${slug#*_}")
  name=$(echo $title | sed 's/\([a-z]\)\([A-Z]\)/\1 \2/g')
  contentHtml="$title".html

  image="$title".png

  if  [[ -e $contentHtml ]]; then
      description=$(sed -n '/<body/,/<\/body>/p' $contentHtml | sed '1d;$d' |  sed 's/"/''/g' | tr '\n' ' ')
  else
      description=""
  fi

  while true; do
      seoMetaDescription=$(ollama run mistral "Act as an seo expert and assist me in writing an SEO meta-description. Please provide your answer in german, not english. What I need from you is exactly one sentence (not longer) that summarizes the input: $(cat $title.md). Please don't use more then 50 words'")
      echo "Generated seo meta-description: $seoMetaDescription"
      gum confirm --selected.background=2 --selected.foreground=0 "Ok ?"

      if [ $? -eq 0 ]; then
          break
      fi
  done

  case $postTitle in
      "Ein Gespräch mit "*)
          guest=${postTitle#"Ein Gespräch mit "}
          guest="<b>Links zum weiterlesen</b><br><br>Mehr Informationen zu $guest: Instagram | Facebook <br><br>"
          ;;

      "Ein Wiedersehen mit "*)
          guest=${postTitle#"Ein Wiedersehen mit "}
          guest="<b>Links zum weiterlesen</b><br><br>Mehr Informationen zu $guest: Instagram | Facebook <br><br>"
          ;;
      *)
          guest=""
          ;;
  esac

  content="<b>Werbefrei</b><br><br>Zusätzlich habt ihr ab sofort die Möglichkeit euch das exklusive <a href='https://www.patreon.com/laufendentdecken'>Patreonfeed</a> zu sichern – werbefrei und liebevoll exportiert.<br><br>Am besten direkt mitmachen und unterstützen: <a href='https://www.patreon.com/laufendentdecken'>Patreon</a><br><br>${guest}Wenn ihr den Podcast direkt ohne Installation hören möchtet, könnt ihr das hier tun: Laufend Entdecken auf Podbay<br><br>Florian: <a href='http://twitter.com/laufenentdecken'>Twitter</a>, <a href='https://www.strava.com/athletes/1651823'>Strava</a><br>Peter: <a href='https://twitter.com/redendentdecken'>Twitter</a>, <a href='https://www.instagram.com/redendentdecken'>Instagram</a>, <a href='https://www.strava.com/athletes/24464941'>Strava</a><br>Geordi: <a href='https://twitter.com/Geordi2504'>Twitter</a>, <a href='https://www.instagram.com/geordi2504/'>Instagram</a>, <a href='https://www.instagram.com/viennarunning/'>Vienna Running Instagram</a>, <a href='https://vienna-running.eu/'>Vienna Running</a><br><br><a href='http://facebook.com/laufendentdeckenblog/'>Facebook</a>, <a href='https://instagram.com/laufendentdeckenpodcast/'>Instagram</a>, <a href='https://www.strava.com/clubs/473847'>Strava Club</a>"

  if [[ -n "$ag1" ]]; then
      content="<b>Werbung</b><br><br>Informiere dich jetzt auf <a href='http://drinkag1.com/laufendentdecken'>drinkag1.com/laufendentdecken</a> , teste AG1 völlig risikofrei mit 90 Tagen Geld-zurück-Garantie und sichere dir bei deiner AG1 Erstbestellung einen kostenlosen Jahresvorrat an Vitamin D3+K2 zur Unterstützung des Immunsystems & 5 praktische Travel Packs! Gesundheitsbezogene Angaben zu AG1 und unser Angebot findest du auf: <a href='http://drinkag1.com/laufendentdecken'>drinkag1.com/laufendentdecken</a><br><br>Auf die Bedeutung einer abwechslungsreichen und ausgewogenen Ernährung und einer gesunden Lebensweise wird hingewiesen. Außer Reichweite von Kindern aufbewahren. Nicht geeignet für Kinder und Jugendliche unter 18 Jahren, schwangere oder stillende Frauen. Die angegebene empfohlene tägliche Verzehrmenge darf nicht überschritten werden.<br><br>$content"
  fi

  if [[ -n "$polestar" ]]; then
      content="<b>Werbung</b><br><br>Alle Informationen zur Aktion von <a href='https://www.polestar.com/at/'>Polestar</a> findest du unter: <a href='https://www.polestar.com/at/polestar-2-2023/'>https://www.polestar.com/at/polestar-2-2023/</a><br>Das Leasingangebot ist gültig bis 30.06.2023<br><br>$content"
  fi

  apiKey=$(op read "op://Podcast/Podlove/credential")

  echo " Initiating episode"

  json=$(curl -s -X POST https://laufendentdecken-podcast.at/wp-json/podlove/v2/episodes \
      --header "Authorization: Basic $apiKey")

  episodeId=$(echo $json | jq -r ' . | "\(.id)"')
  response=$(curl -s -X POST https://laufendentdecken-podcast.at/wp-json/podlove/v2/episodes/$episodeId \
      --header "Authorization: Basic $apiKey" \
      --header 'Content-Type: application/json; charset=utf-8' \
      -d "{ \"slug\": \"$slug\", \"title\": \"$fullPostTitle\", \"number\": \"$postNumber\" }")

  json=$(curl -s -X GET https://laufendentdecken-podcast.at/wp-json/podlove/v2/episodes/$episodeId --header "Authorization: Basic $apiKey")
  postId=$(echo $json | jq -r ' . | "\(.post_id)"')

  echo " Uploading feature image"

  featureMedia=$(curl --request POST \
      --url https://laufendentdecken-podcast.at/wp-json/wp/v2/media \
      --http1.1 \
      --header "authorization: Basic ${apiKey}" \
      --header 'content-type: multipart/form-data' \
      --form "file=@${image}" \
      --form "title=$name" \
      | jq -r '.id')

  postData="{ \"yoast_wpseo_metadesc\": $seoMetaDescription, \"featured_media\": $featureMedia, \"title\":\"$fullPostTitle\", \"status\": \"future\", \"date\": \"$postDate\", \"slug\": \"$postNumber\", \"content\": \"<!-- wp:paragraph -->$description<!-- /wp:paragraph --> <!-- wp:paragraph -->$content<!-- /wp:paragraph -->\" }"

  echo " Updating information"

  response=$(curl --silent -X POST https://laufendentdecken-podcast.at/wp-json/wp/v2/episodes/$postId \
      --header "Authorization: Basic $apiKey" \
      --header 'Content-Type: application/json; charset=utf-8' \
      --data-raw "$postData")

  echo " Setting Assets"
  m4a=$(curl -s -X PUT https://laufendentdecken-podcast.at/wp-json/podlove/v2/episodes/$episodeId/media/2/enable --header "Authorization: Basic $apiKey")
  mp3=$(curl -s -X PUT https://laufendentdecken-podcast.at/wp-json/podlove/v2/episodes/$episodeId/media/3/enable --header "Authorization: Basic $apiKey")

  filename="$title.chapters.txt"
  json="{ \"chapters\": ["

  while IFS= read -r line || [[ -n "$line" ]]; do
      start="${line%% *}"
      start="${start%%.*}"

      title="${line#* }"

      json+="{\"start\": \"$start\", \"title\": \"$title\"},"
  done < "$filename"

  json=${json%?}

  json+="]}"

  echo " Chapter"
  chapters=$(curl -s -X PUT https://laufendentdecken-podcast.at/wp-json/podlove/v2/chapters/$episodeId \
      --header "Authorization: Basic $apiKey" \
      --header 'accept: application/json' \
      --header 'content-type: application/json; charset=utf-8' \
      --data-raw "$json")

}

# :command.parse_requirements
parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --version | -v)
        version_command
        exit
        ;;

      --help | -h)
        long_usage=yes
        lep_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.dependencies_filter
  if command -v aws >/dev/null 2>&1; then
    deps['aws']="$(command -v aws | head -n1)"
  else
    printf "missing dependency: aws\n" >&2
    printf "%s\n" "install by running: 'brew install awscli'" >&2
    exit 1
  fi

  if command -v op >/dev/null 2>&1; then
    deps['op']="$(command -v op | head -n1)"
  else
    printf "missing dependency: op\n" >&2
    printf "%s\n" "install by running: 'brew install 1password-cli'" >&2
    exit 1
  fi

  if command -v jq >/dev/null 2>&1; then
    deps['jq']="$(command -v jq | head -n1)"
  else
    printf "missing dependency: jq\n" >&2
    printf "%s\n" "install by running: 'brew install jq'" >&2
    exit 1
  fi

  if command -v gum >/dev/null 2>&1; then
    deps['gum']="$(command -v gum | head -n1)"
  else
    printf "missing dependency: gum\n" >&2
    printf "%s\n" "install by running: 'brew install gum'" >&2
    exit 1
  fi

  if command -v ollama >/dev/null 2>&1; then
    deps['ollama']="$(command -v ollama | head -n1)"
  else
    printf "missing dependency: ollama\n" >&2
    printf "%s\n" "install by running: 'brew install ollama'" >&2
    exit 1
  fi

  if command -v curl >/dev/null 2>&1; then
    deps['curl']="$(command -v curl | head -n1)"
  else
    printf "missing dependency: curl\n" >&2
    printf "%s\n" "Please install curl" >&2
    exit 1
  fi

  if command -v pandoc >/dev/null 2>&1; then
    deps['pandoc']="$(command -v pandoc | head -n1)"
  else
    printf "missing dependency: pandoc\n" >&2
    printf "%s\n" "install by running: 'brew install jq'" >&2
    exit 1
  fi

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    completions)
      action="completions"
      shift
      lep_completions_parse_requirements "$@"
      shift $#
      ;;

    init)
      action="init"
      shift
      lep_init_parse_requirements "$@"
      shift $#
      ;;

    edit)
      action="edit"
      shift
      lep_edit_parse_requirements "$@"
      shift $#
      ;;

    new)
      action="new"
      shift
      lep_new_parse_requirements "$@"
      shift $#
      ;;

    check)
      action="check"
      shift
      lep_check_parse_requirements "$@"
      shift $#
      ;;

    download)
      action="download"
      shift
      lep_download_parse_requirements "$@"
      shift $#
      ;;

    metadata)
      action="metadata"
      shift
      lep_metadata_parse_requirements "$@"
      shift $#
      ;;

    youtube)
      action="youtube"
      shift
      lep_youtube_parse_requirements "$@"
      shift $#
      ;;

    ftp)
      action="ftp"
      shift
      lep_ftp_parse_requirements "$@"
      shift $#
      ;;

    upload-youtube)
      action="upload-youtube"
      shift
      lep_upload_youtube_parse_requirements "$@"
      shift $#
      ;;

    automation)
      action="automation"
      shift
      lep_automation_parse_requirements "$@"
      shift $#
      ;;

    auphonic | a)
      action="auphonic"
      shift
      lep_auphonic_parse_requirements "$@"
      shift $#
      ;;

    blogpost | cb)
      action="blogpost"
      shift
      lep_blogpost_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      lep_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
lep_completions_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        lep_completions_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="completions"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
lep_init_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        lep_init_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="init"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
lep_edit_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        lep_edit_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="edit"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
lep_new_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        lep_new_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="new"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
lep_check_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        lep_check_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="check"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --skip-youtube)

        # :flag.case_no_arg
        args['--skip-youtube']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
lep_download_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        lep_download_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="download"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --file | -f)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--file']="$2"
          shift
          shift
        else
          printf "%s\n" "--file requires an argument: --file, -f FILE" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

  # :command.required_flags_filter
  if [[ -z ${args['--file']+x} ]]; then
    printf "missing required flag: --file, -f FILE\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
lep_metadata_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        lep_metadata_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="metadata"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --title | -t)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--title']="$2"
          shift
          shift
        else
          printf "%s\n" "--title requires an argument: --title, -t TITLE" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --debug)

        # :flag.case_no_arg
        args['--debug']=1
        shift
        ;;

      # :flag.case
      --no-default-releasedate)

        # :flag.case_no_arg
        args['--no-default-releasedate']=1
        shift
        ;;

      # :flag.case
      --no-default-postnumber)

        # :flag.case_no_arg
        args['--no-default-postnumber']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

  # :command.required_flags_filter
  if [[ -z ${args['--title']+x} ]]; then
    printf "missing required flag: --title, -t TITLE\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
lep_youtube_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        lep_youtube_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="youtube"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --title | -t)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--title']="$2"
          shift
          shift
        else
          printf "%s\n" "--title requires an argument: --title, -t TITLE" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --publish_date | -p)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--publish_date']="$2"
          shift
          shift
        else
          printf "%s\n" "--publish_date requires an argument: --publish_date, -p PUBLISH_DATE" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

  # :command.required_flags_filter
  if [[ -z ${args['--title']+x} ]]; then
    printf "missing required flag: --title, -t TITLE\n" >&2
    exit 1
  fi
  if [[ -z ${args['--publish_date']+x} ]]; then
    printf "missing required flag: --publish_date, -p PUBLISH_DATE\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
lep_ftp_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        lep_ftp_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="ftp"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --file | -f)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--file']="$2"
          shift
          shift
        else
          printf "%s\n" "--file requires an argument: --file, -f FILE" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --name | -n)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--name']="$2"
          shift
          shift
        else
          printf "%s\n" "--name requires an argument: --name, -n NAME" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

  # :command.required_flags_filter
  if [[ -z ${args['--file']+x} ]]; then
    printf "missing required flag: --file, -f FILE\n" >&2
    exit 1
  fi
  if [[ -z ${args['--name']+x} ]]; then
    printf "missing required flag: --name, -n NAME\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
lep_upload_youtube_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        lep_upload_youtube_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="upload-youtube"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
lep_automation_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        lep_automation_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="automation"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --m4a | -m)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          # :flag.validations
          if [[ -n $(validate_file_exists "$2") ]]; then
            printf "validation error in %s:\n%s\n" "--m4a, -m M4A" "$(validate_file_exists "$2")" >&2
            exit 1
          fi

          args['--m4a']="$2"
          shift
          shift
        else
          printf "%s\n" "--m4a requires an argument: --m4a, -m M4A" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --time)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--time']="$2"
          shift
          shift
        else
          printf "%s\n" "--time requires an argument: --time TIME" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --force)

        # :flag.case_no_arg
        args['--force']=1
        shift
        ;;

      # :flag.case
      --ag1)

        # :flag.case_no_arg
        args['--ag1']=1
        shift
        ;;

      # :flag.case
      --polestar)

        # :flag.case_no_arg
        args['--polestar']=1
        shift
        ;;

      # :flag.case
      --debug)

        # :flag.case_no_arg
        args['--debug']=1
        shift
        ;;

      # :flag.case
      --no-default-releasedate)

        # :flag.case_no_arg
        args['--no-default-releasedate']=1
        shift
        ;;

      # :flag.case
      --skip-ftp)

        # :flag.case_no_arg
        args['--skip-ftp']=1
        shift
        ;;

      # :flag.case
      --skip-aws)

        # :flag.case_no_arg
        args['--skip-aws']=1
        shift
        ;;

      # :flag.case
      --skip-auphonic)

        # :flag.case_no_arg
        args['--skip-auphonic']=1
        shift
        ;;

      # :flag.case
      --skip-download)

        # :flag.case_no_arg
        args['--skip-download']=1
        shift
        ;;

      # :flag.case
      --skip-blogpost)

        # :flag.case_no_arg
        args['--skip-blogpost']=1
        shift
        ;;

      # :flag.case
      --skip-youtube)

        # :flag.case_no_arg
        args['--skip-youtube']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

  # :command.default_assignments
  [[ -n ${args['--time']:-} ]] || args['--time']="09:00:00"

}

# :command.parse_requirements
lep_auphonic_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        lep_auphonic_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="auphonic"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --production_name | -n)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--production_name']="$2"
          shift
          shift
        else
          printf "%s\n" "--production_name requires an argument: --production_name, -n PRODUCTION_NAME" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --preset | -p)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--preset']="$2"
          shift
          shift
        else
          printf "%s\n" "--preset requires an argument: --preset, -p PRESET" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --cover_url | -c)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--cover_url']="$2"
          shift
          shift
        else
          printf "%s\n" "--cover_url requires an argument: --cover_url, -c COVER_URL" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --file | -f)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--file']="$2"
          shift
          shift
        else
          printf "%s\n" "--file requires an argument: --file, -f FILE" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --slug | -s)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--slug']="$2"
          shift
          shift
        else
          printf "%s\n" "--slug requires an argument: --slug, -s SLUG" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --description | -d)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--description']="$2"
          shift
          shift
        else
          printf "%s\n" "--description requires an argument: --description, -d DESCRIPTION" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --no-start)

        # :flag.case_no_arg
        args['--no-start']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

  # :command.required_flags_filter
  if [[ -z ${args['--production_name']+x} ]]; then
    printf "missing required flag: --production_name, -n PRODUCTION_NAME\n" >&2
    exit 1
  fi
  if [[ -z ${args['--preset']+x} ]]; then
    printf "missing required flag: --preset, -p PRESET\n" >&2
    exit 1
  fi
  if [[ -z ${args['--cover_url']+x} ]]; then
    printf "missing required flag: --cover_url, -c COVER_URL\n" >&2
    exit 1
  fi
  if [[ -z ${args['--file']+x} ]]; then
    printf "missing required flag: --file, -f FILE\n" >&2
    exit 1
  fi
  if [[ -z ${args['--slug']+x} ]]; then
    printf "missing required flag: --slug, -s SLUG\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
lep_blogpost_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        lep_blogpost_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="blogpost"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --ag1)

        # :flag.case_no_arg
        args['--ag1']=1
        shift
        ;;

      # :flag.case
      --polestar)

        # :flag.case_no_arg
        args['--polestar']=1
        shift
        ;;

      # :flag.case
      --number | -n)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--number']="$2"
          shift
          shift
        else
          printf "%s\n" "--number requires an argument: --number, -n NUMBER" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --title | -t)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--title']="$2"
          shift
          shift
        else
          printf "%s\n" "--title requires an argument: --title, -t TITLE" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --publish_date | -p)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--publish_date']="$2"
          shift
          shift
        else
          printf "%s\n" "--publish_date requires an argument: --publish_date, -p PUBLISH_DATE" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --slug | -s)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--slug']="$2"
          shift
          shift
        else
          printf "%s\n" "--slug requires an argument: --slug, -s SLUG" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

  # :command.required_flags_filter
  if [[ -z ${args['--number']+x} ]]; then
    printf "missing required flag: --number, -n NUMBER\n" >&2
    exit 1
  fi
  if [[ -z ${args['--title']+x} ]]; then
    printf "missing required flag: --title, -t TITLE\n" >&2
    exit 1
  fi
  if [[ -z ${args['--publish_date']+x} ]]; then
    printf "missing required flag: --publish_date, -p PUBLISH_DATE\n" >&2
    exit 1
  fi
  if [[ -z ${args['--slug']+x} ]]; then
    printf "missing required flag: --slug, -s SLUG\n" >&2
    exit 1
  fi

}

# :command.user_hooks
before_hook() {
  # src/before.sh
  op signin --account my.1password.com

}

# :command.initialize
initialize() {
  version="1.0.0"
  long_usage=''
  set -e

  # src/initialize.sh

}

# :command.run
run() {
  declare -A args=()
  declare -A deps=()
  declare -a other_args=()
  declare -a input=()
  normalize_input "$@"
  parse_requirements "${input[@]}"
  before_hook

  case "$action" in
    "completions") lep_completions_command ;;
    "init") lep_init_command ;;
    "edit") lep_edit_command ;;
    "new") lep_new_command ;;
    "check") lep_check_command ;;
    "download") lep_download_command ;;
    "metadata") lep_metadata_command ;;
    "youtube") lep_youtube_command ;;
    "ftp") lep_ftp_command ;;
    "upload-youtube") lep_upload_youtube_command ;;
    "automation") lep_automation_command ;;
    "auphonic") lep_auphonic_command ;;
    "blogpost") lep_blogpost_command ;;
  esac
}

initialize
run "$@"
