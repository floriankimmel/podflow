#!/usr/bin/env bash
# This script was generated by bashly 1.0.2 (https://bashly.dannyb.co)
# Modifying it manually is not recommended

# :wrapper.bash3_bouncer
if [[ "${BASH_VERSINFO:-0}" -lt 4 ]]; then
  printf "bash version 4 or higher is required\n" >&2
  exit 1
fi

# :command.master_script

# :command.version_command
version_command() {
  echo "$version"
}

# :command.usage
lep_usage() {
  if [[ -n $long_usage ]]; then
    printf "lep - Manage the laufendentdecken podcast via terminal\n"
    echo

  else
    printf "lep - Manage the laufendentdecken podcast via terminal\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  lep COMMAND\n"
  printf "  lep [COMMAND] --help | -h\n"
  printf "  lep --version | -v\n"
  echo
  # :command.usage_commands
  printf "%s\n" "Commands:"
  printf "  %s   Initialise episode\n" "init      "
  printf "  %s   Check if ready to start automation\n" "check     "
  printf "  %s   Generate episode metadata\n" "metadata  "
  printf "  %s   Configure youtube video\n" "youtube   "
  printf "  %s   Upload file to self hosted ftp server\n" "ftp       "
  printf "  %s   Upload latest episode and start automatic post processing workflow\n" "automation"
  printf "  %s   Start new auphonic production\n" "auphonic  "
  printf "  %s   Create wordpress blogpost on http://laufendentdecken-podcast.at\n" "blogpost  "
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo
    printf "  %s\n" "--version, -v"
    printf "    Show version number\n"
    echo

  fi
}

# :command.usage
lep_init_usage() {
  if [[ -n $long_usage ]]; then
    printf "lep init - Initialise episode\n"
    echo

  else
    printf "lep init - Initialise episode\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  lep init\n"
  printf "  lep init --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
lep_check_usage() {
  if [[ -n $long_usage ]]; then
    printf "lep check - Check if ready to start automation\n"
    echo

  else
    printf "lep check - Check if ready to start automation\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  lep check\n"
  printf "  lep check --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
lep_metadata_usage() {
  if [[ -n $long_usage ]]; then
    printf "lep metadata - Generate episode metadata\n"
    echo

  else
    printf "lep metadata - Generate episode metadata\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  lep metadata [OPTIONS]\n"
  printf "  lep metadata --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--title, -t TITLE (required)"
    printf "    Episode Title\n"
    echo

    # :flag.usage
    printf "  %s\n" "--debug"
    printf "    Don't change any state in 1password\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
lep_youtube_usage() {
  if [[ -n $long_usage ]]; then
    printf "lep youtube - Configure youtube video\n"
    echo

  else
    printf "lep youtube - Configure youtube video\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  lep youtube [OPTIONS]\n"
  printf "  lep youtube --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--title, -t TITLE (required)"
    printf "    Episode Title\n"
    echo

    # :flag.usage
    printf "  %s\n" "--publish_date, -p PUBLISH_DATE (required)"
    printf "    Publish Date\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
lep_ftp_usage() {
  if [[ -n $long_usage ]]; then
    printf "lep ftp - Upload file to self hosted ftp server\n"
    echo

  else
    printf "lep ftp - Upload file to self hosted ftp server\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  lep ftp [OPTIONS]\n"
  printf "  lep ftp --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--file, -f FILE (required)"
    printf "    File to upload\n"
    echo

    # :flag.usage
    printf "  %s\n" "--name, -n NAME (required)"
    printf "    Name of file on server\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
lep_automation_usage() {
  if [[ -n $long_usage ]]; then
    printf "lep automation - Upload latest episode and start automatic post processing workflow\n"
    echo

  else
    printf "lep automation - Upload latest episode and start automatic post processing workflow\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  lep automation [OPTIONS]\n"
  printf "  lep automation --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--m4a, -m M4A"
    printf "    Episode as m4a\n"
    echo

    # :flag.usage
    printf "  %s\n" "--ag1"
    printf "    This episodes is supportd by AG1\n"
    echo

    # :flag.usage
    printf "  %s\n" "--debug"
    printf "    Dont change\n"
    echo

    # :flag.usage
    printf "  %s\n" "--no-default-releasedate"
    printf "    Change default release date\n"
    echo

    # :flag.usage
    printf "  %s\n" "--skip-ftp"
    printf "    Skip upload to FTP server\n"
    echo

    # :flag.usage
    printf "  %s\n" "--skip-aws"
    printf "    Skip upload to aws\n"
    echo

    # :flag.usage
    printf "  %s\n" "--skip-auphonic"
    printf "    Skip upload to Auphonic\n"
    echo

    # :flag.usage
    printf "  %s\n" "--skip-download"
    printf "    Skip download from patreon\n"
    echo

    # :flag.usage
    printf "  %s\n" "--skip-blogpost"
    printf "    Skip create blogpost\n"
    echo

    # :flag.usage
    printf "  %s\n" "--skip-youtube"
    printf "    Skip scheduling youtube video\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  lep upload --m4a episode.m4a\n"
    echo

  fi
}

# :command.usage
lep_auphonic_usage() {
  if [[ -n $long_usage ]]; then
    printf "lep auphonic - Start new auphonic production\n"
    echo

  else
    printf "lep auphonic - Start new auphonic production\n"
    echo

  fi

  printf "Alias: a\n"
  echo

  printf "%s\n" "Usage:"
  printf "  lep auphonic [OPTIONS]\n"
  printf "  lep auphonic --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--production_name, -n PRODUCTION_NAME (required)"
    printf "    Auphonic production name\n"
    echo

    # :flag.usage
    printf "  %s\n" "--preset, -p PRESET (required)"
    printf "    Auphonic preset\n"
    echo

    # :flag.usage
    printf "  %s\n" "--cover_url, -c COVER_URL (required)"
    printf "    URL of the cover image\n"
    echo

    # :flag.usage
    printf "  %s\n" "--file, -f FILE (required)"
    printf "    File name of the production\n"
    echo

    # :flag.usage
    printf "  %s\n" "--slug, -s SLUG (required)"
    printf "    Slug of the auphonic production\n"
    echo

    # :flag.usage
    printf "  %s\n" "--description, -d DESCRIPTION"
    printf "    Description of the episode\n"
    echo

    # :flag.usage
    printf "  %s\n" "--no-start"
    printf "    Dont automatically start the auphonic production\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  lep auphonic --production_name episode1 --preset \"123823\" --cover_url\n  \"http://url\" --file episode1.m4a --slug episode1\n"
    echo

  fi
}

# :command.usage
lep_blogpost_usage() {
  if [[ -n $long_usage ]]; then
    printf "lep blogpost - Create wordpress blogpost on http://laufendentdecken-podcast.at\n"
    echo

  else
    printf "lep blogpost - Create wordpress blogpost on http://laufendentdecken-podcast.at\n"
    echo

  fi

  printf "Alias: cb\n"
  echo

  printf "%s\n" "Usage:"
  printf "  lep blogpost [OPTIONS]\n"
  printf "  lep blogpost --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--ag1"
    printf "    This episodes is supportd by AG1\n"
    echo

    # :flag.usage
    printf "  %s\n" "--number, -n NUMBER (required)"
    printf "    Episode Number\n"
    echo

    # :flag.usage
    printf "  %s\n" "--title, -t TITLE (required)"
    printf "    Episode Title\n"
    echo

    # :flag.usage
    printf "  %s\n" "--publish_date, -p PUBLISH_DATE (required)"
    printf "    Publish Date\n"
    echo

    # :flag.usage
    printf "  %s\n" "--slug, -s SLUG (required)"
    printf "    Slug of the auphonic production\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  lep create-blogpost --number 1 --title \"Episode Title\" --publish_date\n  \"2049-12-31\" --slug \"slug\"\n"
    echo

  fi
}

# :command.normalize_input
normalize_input() {
  local arg flags

  while [[ $# -gt 0 ]]; do
    arg="$1"
    if [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then
      flags="${BASH_REMATCH[1]}"
      for ((i = 0; i < ${#flags}; i++)); do
        input+=("-${flags:i:1}")
      done
    else
      input+=("$arg")
    fi

    shift
  done
}
# :command.inspect_args
inspect_args() {
  if ((${#args[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!args[@]}" | sort)
    echo args:
    for k in "${sorted_keys[@]}"; do echo "- \${args[$k]} = ${args[$k]}"; done
  else
    echo args: none
  fi

  if ((${#other_args[@]})); then
    echo
    echo other_args:
    echo "- \${other_args[*]} = ${other_args[*]}"
    for i in "${!other_args[@]}"; do
      echo "- \${other_args[$i]} = ${other_args[$i]}"
    done
  fi

  if ((${#deps[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!deps[@]}" | sort)
    echo
    echo deps:
    for k in "${sorted_keys[@]}"; do echo "- \${deps[$k]} = ${deps[$k]}"; done
  fi

}

# :command.user_lib
# src/lib/validations/validate_dir_exists.sh
validate_dir_exists() {
  [[ -d "$1" ]] || echo "must be an existing directory"
}

# src/lib/validations/validate_file_exists.sh
validate_file_exists() {
  [[ -f "$1" ]] || echo "must be an existing file"
}

# src/lib/validations/validate_integer.sh
validate_integer() {
  [[ "$1" =~ ^[0-9]+$ ]] || echo "must be an integer"
}

# src/lib/validations/validate_not_empty.sh
validate_not_empty() {
  [[ -z "$1" ]] && echo "must not be empty"
}

# :command.command_functions
# :command.function
lep_init_command() {
  # src/init_command.sh
  folder=$(basename "$(pwd)")
  touch "$folder.md"
  window=$(tmux display-message -p '#I')
  tmux rename-window -t Aufnahmen:$window $folder
  fish -c "vim $folder.md"

}

# :command.function
lep_check_command() {
  # src/check_command.sh
  folder=$(basename "$(pwd)")
  error=0

  if [[ -e "$folder.m4a" ]]; then
      echo -e "\e[32mï˜ Episode is already exported\e[0m"
  else

      echo -e "\e[31mîª‡ No Episode is exported to automate\e[0m"
      error=1
  fi

  if [[ -e "${folder}_adfree.m4a" ]]; then
      echo -e "\e[32mï˜ Adfree Episode is already exported\e[0m"
  else
      echo -e "\e[33mï± No Adfree Episode \e[0m"
  fi

  if [[ -e "$folder.md" ]]; then
      echo -e "\e[32mï˜ Episode description exists\e[0m"
  else

      echo -e "\e[31mîª‡ No Episode description available\e[0m"
      error=1
  fi

  if [[ -s "$folder.md" ]]; then
      echo -e "\e[32mï˜ Episode description is not empty\e[0m"
  else

      echo -e "\e[31mîª‡ Episode description is empty\e[0m"
      error=1
  fi

  if [[ -e "$folder.png" ]]; then
      echo -e "\e[32mï˜ Episode thumbnail exists\e[0m"
  else

      echo -e "\e[31mîª‡ No Episode thumbnail available\e[0m"
      error=1
  fi

  if [[ -e "${folder}_youtube.png" ]]; then
      echo -e "\e[32mï˜ Episode youtube thumbnail exists\e[0m"
  else

      echo -e "\e[31mîª‡ No Episode youtube thumbnail available\e[0m"
      error=1
  fi

  if [[ -e "$folder.chapters.txt" ]]; then
      echo -e "\e[32mï˜ Episode chapters exists\e[0m"
  else

      echo -e "\e[31mîª‡ No Episode chapters available\e[0m"
      error=1
  fi

  exit $error

}

# :command.function
lep_metadata_command() {
  # src/metadata_command.sh
  title=${args[--title]}
  debug=${args[--debug]}

  dataFile="$title".txt
  contentFile="$title".html
  sourceFile="$title".md

  if ! [[ -e $contentFile ]]; then
      pandoc -s -o $contentFile $sourceFile
  fi

  if ! [[ -e $dataFile ]]; then
      postNumber=$(op item get "Podcast" --format json | jq -r '. | .fields | .[] | select(.label=="Episode") | .value')
      postNumber=$(expr $postNumber + 1)

      if [[ -z "$debug" ]]; then
          op item edit 'Podcast' 'Episode='$postNumber > /dev/null
      fi

      echo "Title Template"
      echo "(1) Ein GesprÃ¤ch mit "
      echo "(2) Ein Wiedersehen mit "
      echo "(*) Custom"

      while true
      do
          read -p "Please choose: " option

          case $option in
              1)
                  postTitle="Ein GesprÃ¤ch mit "
                  break
                  ;;
              2)
                  postTitle="Ein Wiedersehen mit "
                  break
                  ;;
              *)
                  postTitle=""
                  break
                  ;;
          esac
      done

      if [[ -n "$postTitle" ]]; then
          name=$(echo $title | sed 's/\([a-z]\)\([A-Z]\)/\1 \2/g')
          postTitle=$postTitle$name
      else
          read -p "Custom title: " postTitle
      fi

      if [[ -n "$noDefaultReleaseDate" ]] then
          while true; do
              read -p "Release Date: $nextFriday): " postDate

              if [[ "$postDate" =~ ^[0-9]{4}-[0-9]{2}-[0-9]{2}$ ]]; then
                  break

              fi
          done
      else

          postDate=$(date -v+friday '+%Y-%m-%d')

      fi

      echo "$postNumber,$postTitle,$postDate" >> $dataFile
  fi

  IFS=',' read -r postNumber postTitle postDate <<< "$(head -n 1 "$title"".txt")"

  echo "ïƒ… Kopiere Titel in Clipboard"
  echo "LEP#$postNumber - $postTitle" | pbcopy -Prefer r

  echo "ïƒ… Kopiere Content in Clipboard"
  pandoc -s -f html -t plain $contentFile | sed -e '1,2d' | pbcopy -Prefer r

}

# :command.function
lep_youtube_command() {
  # src/youtube_command.sh
  #!/bin/bash

  PUBLISH_DATE=$(date -jf "%Y-%m-%d %H:%M:%S" "${args[--publish_date]}" "+%Y-%m-%dT%H:%M:%S%z")
  DESCRIPTION=${args[--title]}

  API_KEY=$(op item get "YoutubeApiKey" --format json | jq -r '. | .fields | .[] | select(.label=="password") | .value')

  local length="${#DESCRIPTION}"
  local result=''

  for ((i = 0; i < length; i++)); do
      local char="${DESCRIPTION:i:1}"
      case $char in
          [a-zA-Z0-9.~_-])
              result+="$char"
              ;;
          *)
              printf -v hex '%%%02X' "'$char"
              result+="$hex"
              ;;
      esac
  done

  # Set the necessary scopes for the API request
  SCOPES="https://www.googleapis.com/auth/youtube.force-ssl"

  # Set your API key file path and application name
  API_KEY_FILE="/Users/fkimmel/Dropbox/Tresor/key.json"
  APPLICATION_NAME="CLI"

  credentials="/Users/fkimmel/Library/Application Support/google-oauthlib-tool/credentials.json"

  if ! [[ -e $credentials ]]; then
      google-oauthlib-tool --client-secrets $API_KEY_FILE --scope $SCOPES --save

  fi

  client_id=$(jq -r '.client_id' "$credentials")
  client_secret=$(jq -r '.client_secret' "$credentials")
  refresh_token=$(jq -r '.refresh_token' "$credentials")

  # Get the access token
  ACCESS_TOKEN=$(curl -s -X POST "https://oauth2.googleapis.com/token" \
                      -H "Content-Type: application/x-www-form-urlencoded" \
                      -d "client_id=$client_id&client_secret=$client_secret&refresh_token=$refresh_token&grant_type=refresh_token" \
                      | jq -r '.access_token')

  # Send a request to the YouTube Data API to search for the video
  JSON=$(curl -s "https://www.googleapis.com/youtube/v3/search?key=$API_KEY&q=$result&part=id&part=snippet&maxResults=1&type=video&forMine=true" \
      --header "Authorization: Bearer $ACCESS_TOKEN" \
      --header 'Accept: application/json' \
  )

  # Parse the JSON response to extract the video ID
  VIDEO_ID=$(echo "$JSON" | jq -r '.items[0].id.videoId')

  # Print the video ID
  echo "The video ID is: $VIDEO_ID"

  REQUEST_BODY=$(jq -n --arg videoId "$VIDEO_ID" --arg date $PUBLISH_DATE '{ id: $videoId, status: { privacyStatus: "private", "publishAt": $date , "license": "youtube", "publicStatsViewable": true } }')

  # Make the API request to update the video
  curl -X PUT "https://youtube.googleapis.com/youtube/v3/videos?part=status" \
      --header "Authorization: Bearer $ACCESS_TOKEN" \
      --header 'Accept: application/json' \
      --header 'Content-Type: application/json' \
      --data "$REQUEST_BODY"

  echo "ï…¦ Youtube Video has been scheduled"

}

# :command.function
lep_ftp_command() {
  # src/ftp_command.sh
  file=${args[--file]}
  name=${args[--name]}

  server_pwd=$(op item get "LEP_FTP" --format json | jq -r '. | .fields | .[] | select(.label=="password") | .value')
  server_username=$(op item get "LEP_FTP" --format json | jq -r '. | .fields | .[] | select(.label=="username") | .value')

  curl --user $server_username:$server_pwd --upload-file $file ftp://rssfeed.laufendentdecken-podcast.at/$name

}

# :command.function
lep_automation_command() {
  # src/automation_command.sh
  skipFtp=${args[--skip-ftp]}
  skipAws=${args[--skip-aws]}
  skipAuphonic=${args[--skip-auphonic]}
  skipDownload=${args[--skip-download]}
  skipBlogpost=${args[--skip-blogpost]}
  skipYoutube=${args[--skip-youtube]}
  noDefaultReleaseDate=${args[--no-default-releasedate]}

  defaultAirTime="09:00:00"

  ag1=${args[--ag1]}
  debug=${args[--debug]}
  add=$([ -n "$ag1" ] && echo "true" || echo "false")

  episode=${args[--m4a]}
  if [[ -z "$episode" ]]; then
      episode=$(basename "$(pwd)")
  fi

  lep check

  if [ $? -ne 0 ]; then
    exit 1
  fi

  echo "ï‹Žó°€‚Start automatic workflow for file $episode"

  title=$(echo "$episode" | cut -d'.' -f 1)

  if [[ -e "$title"_adfree.m4a ]] && [[ "$add" = "false" ]]; then
      echo "Adfree version detected, but no advirtesement provided"
      echo "Supported Advirtesements:"
      echo "(1) ag1"

      while true
      do
          read -p "Please choose: " option

          case $option in
              1)
                  ag1="1"
                  break
                  ;;
              *)
                  ;;
          esac
      done
  fi

  if [[ -n "$debug" ]]; then
      lep metadata --title $title --debug

  else

      lep metadata --title $title

  fi

  IFS=',' read -r postNumber postTitle postDate <<< "$(head -n 1 "$title"".txt")"

  echo "ï‹Ž  Automate episode 'LEP#$postNumber - $postTitle' scheduled for $postDate"

  chapters=$(<"$title".chapters.txt)
  cover="$title".png

  if [[ "$add" = "true" ]]; then
      episodeAdFree="$title"_adfree.m4a
      titleAdFree="$title"_adfree
  else
      episodeAdFree=$episode
      titleAdFree=$title
  fi

  coverYoutube="$title"_youtube.png
  baseUrl="https://rssfeed.laufendentdecken-podcast.at/data/"

  coverWithPostNumber="$postNumber"_"$cover"
  coverYoutubeWithPostNumber="$postNumber"_"$coverYoutube"

  coverUrl="$baseUrl$coverWithPostNumber"
  coverUrlYoutube="$baseUrl$coverYoutubeWithPostNumber"

  episodeWithPostNumber="$postNumber"_"$episode"
  episodeAdFreeWithPostNumber="$postNumber"_"$episodeAdFree"
  slug="$postNumber"_"$title"
  slugAdFree="$postNumber"_"$titleAdFree"

  if [[ -z "$skipFtp" ]]; then
      echo
      echo "ïƒ®  Upload episode to FTP Server"
      lep ftp --file $episode --name $episodeWithPostNumber

      if [[ "$add" = "true" ]]; then
          echo "ïƒ®  Upload adfree episode to FTP Server"
          lep ftp --file $episodeAdFree --name $episodeAdFreeWithPostNumber
      fi

      echo "ïƒ®  Upload cover to FTP Server"
      lep ftp --file $cover --name $coverWithPostNumber
      echo "ïƒ®  Upload youtube cover to FTP Server"
      lep ftp --file $coverYoutube --name $coverYoutubeWithPostNumber

  fi

  if [ $? -ne 0 ]; then
    exit 1
  fi

  if [[ -z "$skipAws" ]]; then
      echo
      echo "î‰ Backup to S3"

      aws s3 cp $episode s3://laufendentdecken-podcast/$episodeWithPostNumber
      aws s3 cp s3://laufendentdecken-podcast/$episodeWithPostNumber s3://laufendentdecken-podcast-backup/

      if [[ "$add" = "true" ]]; then
          aws s3 cp $episodeAdFree s3://laufendentdecken-podcast/$episodeAdFreeWithPostNumber
          aws s3 cp s3://laufendentdecken-podcast/$episodeAdFreeWithPostNumber s3://laufendentdecken-podcast-backup/
      fi
  fi

  if [ $? -ne 0 ]; then
    exit 1
  fi

  if [[ -z "$skipAuphonic" ]]; then
      episodePreset="WbQunVJaZFitr3z74XTyxJ"
      youtubePreset="M9ageytQCjaFAYn7EjSYPZ"

      description=$(pbpaste | tr '\n' ' ')
      youtubeDescription=$(echo -e "${description}\n\nHÃ¶rt rein auf:\nðŸ”—Https://laufendentdecken.at/$postNumber/\n\nUnd natÃ¼rlich auf\nðŸŽ§Spotify, iTunes, Google Podcast, zencastr und in allen podcatchern Ã¼ber das RSS Feed.\n\nâœ… Folge uns auf Instagram @laufendentdeckenpodcast , @floderandere und @redendentdecken\n\nUnd auf Facebook https://www.facebook.com/laufendentdeckenpodcast/\n\nWer uns unterstÃ¼tzen mag: https://www.patreon.com/laufendentdecken\noder Steady: https://steadyhq.com/de/laufendentdecken")

      lep auphonic  \
          --production_name $title \
          --preset $episodePreset\
          --cover_url $coverUrl \
          --file $episodeWithPostNumber \
          --slug $slug

      lep auphonic  \
          --production_name "LEP#$postNumber - $postTitle" \
          --preset $youtubePreset \
          --cover_url $coverUrlYoutube \
          --file $episodeWithPostNumber \
          --slug $slug \
          --description "$youtubeDescription"

      if [[ "$add" = "true" ]]; then
          lep auphonic  \
              --production_name "$title (adfree)" \
              --preset $episodePreset \
              --cover_url $coverUrl \
              --file $episodeAdFreeWithPostNumber \
              --slug $slug
      fi

      echo "ï…Š Podcast successfully uploaded"
  fi

  if [ $? -ne 0 ]; then
    exit 1
  fi

  if [[ -z "$skipDownload" ]]; then
      echo
      echo "î«‚ Download adfree version again to be able to upload it to patroen/steady"
      curl https://rssfeed.laufendentdecken-podcast.at/data/$slugAdFree.mp3 --output ~/Downloads/$slugAdFree.mp3
  fi

  if [ $? -ne 0 ]; then
    exit 1
  fi

  if [[ -z "$skipBlogpost" ]]; then
      echo
      echo "î¬†ó°œCreate Episode on Website"

      if [[ "$add" = "false" ]]; then
          lep blogpost \
              --number $postNumber \
              --title "$postTitle" \
              --publish_date "$postDate $defaultAirTime" \
              --slug $slug
      fi

      if [[ -n "$ag1" ]]; then
          lep blogpost \
              --number $postNumber \
              --title "$postTitle" \
              --publish_date "$postDate $defaultAirTime" \
              --slug $slug \
              --ag1
      fi

  fi

  if [[ -z "$skipYoutube" ]]; then
      echo
      echo "ï…¦ Schedule youtube video"
      lep youtube \
          --title "LEP#$postNumber" \
          --publish_date "$postDate $defaultAirTime"
  fi

}

# :command.function
lep_auphonic_command() {
  # src/auphonic_command.sh
  title=${args[--slug]}
  episode=${args[--file]}
  coverUrl=${args[--cover_url]}
  auphonicTitle=${args[--production_name]}
  preset=${args[--preset]}
  noStart=${args[--no-start]}
  description=${args[--description]}

  name=$(echo "${title#*_}")
  chapters=$(<"$name".chapters.txt)

  auphonic_pwd=$(op item get "Auphonic" --format json | jq -r '. | .fields | .[] | select(.label=="password") | .value')
  auphonic_username=$( op item get "Auphonic" --format json | jq -r '. | .fields | .[] | select(.purpose=="USERNAME") | .value')

  action="start"

  # If no start is set, we just want to save the production
  if [[ -n "$noStart" ]]; then
      action="save"
  fi

  echo
  echo
  echo "ï‡‡ Create $auphonicTitle Production"
  json=$(curl -s -X POST https://auphonic.com/api/simple/productions.json \
       -u $auphonic_username:$auphonic_pwd \
       -F "preset=$preset" \
       -F "service=Tz96q8s6vs7JetJeqD6PCC" \
       -F "title=$auphonicTitle" \
       -F "track=$title" \
       -F "chapters=$chapters" \
       -F "input_file=$episode" \
       -F "image=$coverUrl" \
       -F "summary=$description" \
       -F "action=$action")

  # Only query the status if we started the production
  if [[ -z "$noStart" ]]; then
      echo "î«“ Production started"
      content=$(echo $json | jq -r ' . | "\(.data.status_string):\(.data.uuid)"')
      IFS=':' read -ra response <<< "$content"

      status_string=${response[0]}
      uuid=${response[1]}

      echo "UUID: $uuid"
      echo -ne "Auphonic status: $status_string \r"

      while [[ $status_string != "Done"  ]]
      do
          json=$(curl -s -X GET https://auphonic.com/api/production/$uuid.json \
              -u $auphonic_username:$auphonic_pwd)

          status_string=$(echo $json | jq -r ' . | .data.status_string')

          echo -ne "Auphonic status: $status_string                         \r"
          sleep 2
      done
  else
      echo "î­‰ Production $auphonicTitle saved"
  fi

}

# :command.function
lep_blogpost_command() {
  # src/blogpost_command.sh
  postNumber=${args[--number]}
  postTitle=${args[--title]}
  postDate=${args[--publish_date]}
  slug=${args[--slug]}

  ag1=${args[--ag1]}

  fullPostTitle="LEP#$postNumber - $postTitle"

  title=$(echo "${slug#*_}")
  name=$(echo $title | sed 's/\([a-z]\)\([A-Z]\)/\1 \2/g')
  contentHtml="$title".html

  image="$title".png

  if  [[ -e $contentHtml ]]; then
      description=$(sed -n '/<body/,/<\/body>/p' $contentHtml | sed '1d;$d' |  sed 's/"/''/g' | tr '\n' ' ')
  else
      description=""
  fi

  case $postTitle in
      "Ein GesprÃ¤ch mit "*)
          guest=${postTitle#"Ein GesprÃ¤ch mit "}
          guest="Mehr Informationen zu $guest:Â Instagram | Facebook <br><br>"
          ;;

      "Ein Wiedersehen mit "*)
          guest=${postTitle#"Ein Wiedersehen mit "}
          guest="Mehr Informationen zu $guest:Â Instagram | Facebook <br><br>"
          ;;
      *)
          guest=""
          ;;
  esac

  content="<b>Werbefrei</b><br><br>ZusÃ¤tzlich habt ihr ab sofort die MÃ¶glichkeit euch das exklusive <a href='https://www.patreon.com/laufendentdecken'>Patreonfeed</a> zu sichern â€“ werbefrei und liebevoll exportiert.<br><br>Am besten direkt mitmachen und unterstÃ¼tzen: <a href='https://www.patreon.com/laufendentdecken'>Patreon</a><br><br><b>Links zum weiterlesen</b><br><br>$guest Wenn ihr den Podcast direkt ohne Installation hÃ¶ren mÃ¶chtet, kÃ¶nnt ihr das hier tun: Laufend Entdecken auf Podbay<br><br>Florian:Â <a href='http://twitter.com/laufenentdecken'>Twitter</a>,Â <a href='https://www.strava.com/athletes/1651823'>Strava</a><br>Peter:Â <a href='https://twitter.com/redendentdecken'>Twitter</a>,Â <a href='https://www.instagram.com/redendentdecken'>Instagram</a>,Â <a href='https://www.strava.com/athletes/24464941'>Strava</a><br><br><a href='http://facebook.com/laufendentdeckenblog/'>Facebook</a>,Â <a href='https://instagram.com/laufendentdeckenpodcast/'>Instagram</a>,Â <a href='https://www.strava.com/clubs/473847'>Strava Club</a>"

  if [[ -n "$ag1" ]]; then
      content="<b>Werbung</b><br><br>Informiere dich jetzt auf <a href='http://athleticgreens.com/laufendentdecken'>athleticgreens.com/laufendentdecken</a> , teste AG1 vÃ¶llig risikofrei mit 90 Tagen Geld-zurÃ¼ck-Garantie und sichere dir bei deiner AG1 Erstbestellung einen kostenlosen Jahresvorrat an Vitamin D3+K2 zur UnterstÃ¼tzung des Immunsystems & 5 praktische Travel Packs! Gesundheitsbezogene Angaben zu AG1 und unser Angebot findest du auf: <a href='http://athleticgreens.com/laufendentdecken'>athleticgreens.com/laufendentdecken</a><br><br>Auf die Bedeutung einer abwechslungsreichen und ausgewogenen ErnÃ¤hrung und einer gesunden Lebensweise wird hingewiesen. AuÃŸer Reichweite von Kindern aufbewahren. Nicht geeignet fÃ¼r Kinder und Jugendliche unter 18 Jahren, schwangere oder stillende Frauen. Die angegebene empfohlene tÃ¤gliche Verzehrmenge darf nicht Ã¼berschritten werden.<br><br>$content"
  fi

  apiKey=$(op item get "PodloveApiKey" --format json | jq -r '. | .fields | .[] | select(.label=="password") | .value')

  json=$(curl  -s -X POST https://laufendentdecken-podcast.at/wp-json/podlove/v2/episodes --header "Authorization: Basic $apiKey")

  episodeId=$(echo $json | jq -r ' . | "\(.id)"')
  response=$(curl -s -X POST https://laufendentdecken-podcast.at/wp-json/podlove/v2/episodes/$episodeId \
      --header "Authorization: Basic $apiKey" \
      --header 'Content-Type: application/json; charset=utf-8' \
      -d "{ \"slug\": \"$slug\", \"title\": \"$fullPostTitle\", \"number\": \"$postNumber\" }")

  json=$(curl -s -X GET https://laufendentdecken-podcast.at/wp-json/podlove/v2/episodes/$episodeId --header "Authorization: Basic $apiKey")
  postId=$(echo $json | jq -r ' . | "\(.post_id)"')

  featureMedia=$(curl --silent \
      --request POST \
      --url https://laufendentdecken-podcast.at/wp-json/wp/v2/media \
      --header "authorization: Basic ${apiKey}" \
      --header 'content-type: multipart/form-data' \
      --form "file=@${image}" \
      --form "title=$name" \
      | jq -r '.id')

  postData="{ \"featured_media\": $featureMedia, \"title\":\"$fullPostTitle\", \"status\": \"future\", \"date\": \"$postDate\", \"slug\": \"$postNumber\", \"content\": \"<!-- wp:paragraph -->$description<!-- /wp:paragraph --> <!-- wp:paragraph -->$content<!-- /wp:paragraph -->\" }"
  echo $postData
  response=$(curl --silent -X POST https://laufendentdecken-podcast.at/wp-json/wp/v2/episodes/$postId \
      --header "Authorization: Basic $apiKey" \
      --header 'Content-Type: application/json; charset=utf-8' \
      --data-raw "$postData")
  echo $response

  echo "Blogpost erstellt"

}

# :command.parse_requirements
parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --version | -v)
        version_command
        exit
        ;;

      --help | -h)
        long_usage=yes
        lep_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.dependencies_filter
  if command -v aws >/dev/null 2>&1; then
    deps['aws']="$(command -v aws | head -n1)"
  else
    printf "missing dependency: aws\n" >&2
    printf "%s\n" "install by running: 'brew install awscli'" >&2
    exit 1
  fi

  if command -v op >/dev/null 2>&1; then
    deps['op']="$(command -v op | head -n1)"
  else
    printf "missing dependency: op\n" >&2
    printf "%s\n" "install by running: 'brew install 1password-cli'" >&2
    exit 1
  fi

  if command -v jq >/dev/null 2>&1; then
    deps['jq']="$(command -v jq | head -n1)"
  else
    printf "missing dependency: jq\n" >&2
    printf "%s\n" "install by running: 'brew install jq'" >&2
    exit 1
  fi

  if command -v curl >/dev/null 2>&1; then
    deps['curl']="$(command -v curl | head -n1)"
  else
    printf "missing dependency: curl\n" >&2
    printf "%s\n" "Please install curl" >&2
    exit 1
  fi

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    init)
      action="init"
      shift
      lep_init_parse_requirements "$@"
      shift $#
      ;;

    check)
      action="check"
      shift
      lep_check_parse_requirements "$@"
      shift $#
      ;;

    metadata)
      action="metadata"
      shift
      lep_metadata_parse_requirements "$@"
      shift $#
      ;;

    youtube)
      action="youtube"
      shift
      lep_youtube_parse_requirements "$@"
      shift $#
      ;;

    ftp)
      action="ftp"
      shift
      lep_ftp_parse_requirements "$@"
      shift $#
      ;;

    automation)
      action="automation"
      shift
      lep_automation_parse_requirements "$@"
      shift $#
      ;;

    auphonic | a)
      action="auphonic"
      shift
      lep_auphonic_parse_requirements "$@"
      shift $#
      ;;

    blogpost | cb)
      action="blogpost"
      shift
      lep_blogpost_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      lep_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
lep_init_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        lep_init_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="init"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
lep_check_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        lep_check_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="check"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
lep_metadata_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        lep_metadata_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="metadata"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --title | -t)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--title']="$2"
          shift
          shift
        else
          printf "%s\n" "--title requires an argument: --title, -t TITLE" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --debug)

        # :flag.case_no_arg
        args['--debug']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

  # :command.required_flags_filter
  if [[ -z ${args['--title']+x} ]]; then
    printf "missing required flag: --title, -t TITLE\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
lep_youtube_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        lep_youtube_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="youtube"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --title | -t)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--title']="$2"
          shift
          shift
        else
          printf "%s\n" "--title requires an argument: --title, -t TITLE" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --publish_date | -p)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--publish_date']="$2"
          shift
          shift
        else
          printf "%s\n" "--publish_date requires an argument: --publish_date, -p PUBLISH_DATE" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

  # :command.required_flags_filter
  if [[ -z ${args['--title']+x} ]]; then
    printf "missing required flag: --title, -t TITLE\n" >&2
    exit 1
  fi
  if [[ -z ${args['--publish_date']+x} ]]; then
    printf "missing required flag: --publish_date, -p PUBLISH_DATE\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
lep_ftp_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        lep_ftp_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="ftp"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --file | -f)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--file']="$2"
          shift
          shift
        else
          printf "%s\n" "--file requires an argument: --file, -f FILE" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --name | -n)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--name']="$2"
          shift
          shift
        else
          printf "%s\n" "--name requires an argument: --name, -n NAME" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

  # :command.required_flags_filter
  if [[ -z ${args['--file']+x} ]]; then
    printf "missing required flag: --file, -f FILE\n" >&2
    exit 1
  fi
  if [[ -z ${args['--name']+x} ]]; then
    printf "missing required flag: --name, -n NAME\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
lep_automation_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        lep_automation_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="automation"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --m4a | -m)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          # :flag.validations
          if [[ -n $(validate_file_exists "$2") ]]; then
            printf "validation error in %s:\n%s\n" "--m4a, -m M4A" "$(validate_file_exists "$2")" >&2
            exit 1
          fi

          args['--m4a']="$2"
          shift
          shift
        else
          printf "%s\n" "--m4a requires an argument: --m4a, -m M4A" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --ag1)

        # :flag.case_no_arg
        args['--ag1']=1
        shift
        ;;

      # :flag.case
      --debug)

        # :flag.case_no_arg
        args['--debug']=1
        shift
        ;;

      # :flag.case
      --no-default-releasedate)

        # :flag.case_no_arg
        args['--no-default-releasedate']=1
        shift
        ;;

      # :flag.case
      --skip-ftp)

        # :flag.case_no_arg
        args['--skip-ftp']=1
        shift
        ;;

      # :flag.case
      --skip-aws)

        # :flag.case_no_arg
        args['--skip-aws']=1
        shift
        ;;

      # :flag.case
      --skip-auphonic)

        # :flag.case_no_arg
        args['--skip-auphonic']=1
        shift
        ;;

      # :flag.case
      --skip-download)

        # :flag.case_no_arg
        args['--skip-download']=1
        shift
        ;;

      # :flag.case
      --skip-blogpost)

        # :flag.case_no_arg
        args['--skip-blogpost']=1
        shift
        ;;

      # :flag.case
      --skip-youtube)

        # :flag.case_no_arg
        args['--skip-youtube']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
lep_auphonic_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        lep_auphonic_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="auphonic"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --production_name | -n)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--production_name']="$2"
          shift
          shift
        else
          printf "%s\n" "--production_name requires an argument: --production_name, -n PRODUCTION_NAME" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --preset | -p)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--preset']="$2"
          shift
          shift
        else
          printf "%s\n" "--preset requires an argument: --preset, -p PRESET" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --cover_url | -c)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--cover_url']="$2"
          shift
          shift
        else
          printf "%s\n" "--cover_url requires an argument: --cover_url, -c COVER_URL" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --file | -f)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--file']="$2"
          shift
          shift
        else
          printf "%s\n" "--file requires an argument: --file, -f FILE" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --slug | -s)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--slug']="$2"
          shift
          shift
        else
          printf "%s\n" "--slug requires an argument: --slug, -s SLUG" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --description | -d)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--description']="$2"
          shift
          shift
        else
          printf "%s\n" "--description requires an argument: --description, -d DESCRIPTION" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --no-start)

        # :flag.case_no_arg
        args['--no-start']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

  # :command.required_flags_filter
  if [[ -z ${args['--production_name']+x} ]]; then
    printf "missing required flag: --production_name, -n PRODUCTION_NAME\n" >&2
    exit 1
  fi
  if [[ -z ${args['--preset']+x} ]]; then
    printf "missing required flag: --preset, -p PRESET\n" >&2
    exit 1
  fi
  if [[ -z ${args['--cover_url']+x} ]]; then
    printf "missing required flag: --cover_url, -c COVER_URL\n" >&2
    exit 1
  fi
  if [[ -z ${args['--file']+x} ]]; then
    printf "missing required flag: --file, -f FILE\n" >&2
    exit 1
  fi
  if [[ -z ${args['--slug']+x} ]]; then
    printf "missing required flag: --slug, -s SLUG\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
lep_blogpost_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        lep_blogpost_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="blogpost"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --ag1)

        # :flag.case_no_arg
        args['--ag1']=1
        shift
        ;;

      # :flag.case
      --number | -n)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--number']="$2"
          shift
          shift
        else
          printf "%s\n" "--number requires an argument: --number, -n NUMBER" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --title | -t)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--title']="$2"
          shift
          shift
        else
          printf "%s\n" "--title requires an argument: --title, -t TITLE" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --publish_date | -p)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--publish_date']="$2"
          shift
          shift
        else
          printf "%s\n" "--publish_date requires an argument: --publish_date, -p PUBLISH_DATE" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --slug | -s)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--slug']="$2"
          shift
          shift
        else
          printf "%s\n" "--slug requires an argument: --slug, -s SLUG" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

  # :command.required_flags_filter
  if [[ -z ${args['--number']+x} ]]; then
    printf "missing required flag: --number, -n NUMBER\n" >&2
    exit 1
  fi
  if [[ -z ${args['--title']+x} ]]; then
    printf "missing required flag: --title, -t TITLE\n" >&2
    exit 1
  fi
  if [[ -z ${args['--publish_date']+x} ]]; then
    printf "missing required flag: --publish_date, -p PUBLISH_DATE\n" >&2
    exit 1
  fi
  if [[ -z ${args['--slug']+x} ]]; then
    printf "missing required flag: --slug, -s SLUG\n" >&2
    exit 1
  fi

}

# :command.user_hooks
before_hook() {
  # src/before.sh
  op signin --account my.1password.com

}

# :command.initialize
initialize() {
  version="1.0.0"
  long_usage=''
  set -e

  # src/initialize.sh

}

# :command.run
run() {
  declare -A args=()
  declare -A deps=()
  declare -a other_args=()
  declare -a input=()
  normalize_input "$@"
  parse_requirements "${input[@]}"
  before_hook

  case "$action" in
    "init") lep_init_command ;;
    "check") lep_check_command ;;
    "metadata") lep_metadata_command ;;
    "youtube") lep_youtube_command ;;
    "ftp") lep_ftp_command ;;
    "automation") lep_automation_command ;;
    "auphonic") lep_auphonic_command ;;
    "blogpost") lep_blogpost_command ;;
  esac
}

initialize
run "$@"
